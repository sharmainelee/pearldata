---
title: "everything"
output: html_document
date: "2025-08-13"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 1. Proportion

#startswith include gold overtone e.g gold silver, gold white

```{r}
dat <- PearlOperationalData

# Convert Colour to character (avoids factor issues)
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove oysters with no pearls (missing or blank)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary Gold variable
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)

# Convert Saibo donor ID to factor
dat$First_Op_Data_Saibo_No <- as.factor(dat$First_Op_Data_Saibo_No)

# Fit logistic regression
model <- glm(Gold ~ First_Op_Data_Saibo_No, data = dat, family = binomial)
summary(model)

```


#gold + gold overtones
```{r}
library(ggplot2)
library(dplyr)

# Calculate proportion of gold pearls per donor
prop_data <- dat %>%
  group_by(First_Op_Data_Saibo_No) %>%
  summarise(
    n = n(),
    gold_rate = mean(Gold)
  )

# Bar plot
p_gold <- ggplot(prop_data, aes(x = First_Op_Data_Saibo_No, y = gold_rate)) +
  geom_col(fill = "goldenrod") +
  labs(
    x = "Saibo Donor ID",
    y = "Proportion of Gold Pearls",
    title = "Proportion of Gold Pearls by Saibo Donor"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_gold

```




###silver + overtones silver gold, silver pink, silver white

```{r}
dat <- PearlOperationalData

# Convert Colour to character (avoids factor issues)
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove oysters with no pearls (missing or blank)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary Gold variable
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)

# Convert Saibo donor ID to factor
dat$First_Op_Data_Saibo_No <- as.factor(dat$First_Op_Data_Saibo_No)

# Fit logistic regression
model <- glm(Silver ~ First_Op_Data_Saibo_No, data = dat, family = binomial)
summary(model)

```


#silver + overtones

```{r}
library(ggplot2)
library(dplyr)

# Calculate proportion of gold pearls per donor
prop_data <- dat %>%
  group_by(First_Op_Data_Saibo_No) %>%
  summarise(
    n = n(),
    silver_rate = mean(Silver)
  )

# Bar plot
p_silver <- ggplot(prop_data, aes(x = First_Op_Data_Saibo_No, y = silver_rate)) +
  geom_col(fill = "#c0c0c0") +
  labs(
    x = "Saibo Donor ID",
    y = "Proportion of Silver Pearls",
    title = "Proportion of Silver Pearls by Saibo Donor"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_silver

```




# white + overtones white cream, white gold, white pink, white silver

```{r}
dat <- PearlOperationalData

# Convert Colour to character (avoids factor issues)
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove oysters with no pearls (missing or blank)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary Gold variable
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)

# Convert Saibo donor ID to factor
dat$First_Op_Data_Saibo_No <- as.factor(dat$First_Op_Data_Saibo_No)

# Fit logistic regression
model <- glm(White ~ First_Op_Data_Saibo_No, data = dat, family = binomial)
summary(model)

```


#white + overtones

```{r}
library(ggplot2)
library(dplyr)

# Calculate proportion of gold pearls per donor
prop_data <- dat %>%
  group_by(First_Op_Data_Saibo_No) %>%
  summarise(
    n = n(),
    white_rate = mean(White)
  )

# Bar plot
p_white <- ggplot(prop_data, aes(x = First_Op_Data_Saibo_No, y = white_rate)) +
  geom_col(fill = "#E3DAC9") +
  labs(
    x = "Saibo Donor ID",
    y = "Proportion of White Pearls",
    title = "Proportion of White Pearls by Saibo Donor"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_white

```



# cream 

```{r}
dat <- PearlOperationalData

# Convert Colour to character (avoids factor issues)
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove oysters with no pearls (missing or blank)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary Gold variable
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)

# Convert Saibo donor ID to factor
dat$First_Op_Data_Saibo_No <- as.factor(dat$First_Op_Data_Saibo_No)

# Fit logistic regression
model <- glm(Cream ~ First_Op_Data_Saibo_No, data = dat, family = binomial)
summary(model)

```


#cream 

```{r}
library(ggplot2)
library(dplyr)

# Calculate proportion of cream pearls per donor
prop_data <- dat %>%
  group_by(First_Op_Data_Saibo_No) %>%
  summarise(
    n = n(),
    cream_rate = mean(Cream)
  )

# Bar plot
p_cream <- ggplot(prop_data, aes(x = First_Op_Data_Saibo_No, y = cream_rate)) +
  geom_col(fill = "#FFFDD0") +
  labs(
    x = "Saibo Donor ID",
    y = "Proportion of Cream Pearls",
    title = "Proportion of Cream Pearls by Saibo Donor"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_cream

```


# champagne

```{r}
dat <- PearlOperationalData

# Convert Colour to character (avoids factor issues)
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove oysters with no pearls (missing or blank)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary Gold variable
dat$Champ <- ifelse(grepl("Champ",dat$Pearl_Grading_Data_Colour), 1, 0)

# Convert Saibo donor ID to factor
dat$First_Op_Data_Saibo_No <- as.factor(dat$First_Op_Data_Saibo_No)

# Fit logistic regression
model <- glm(Champ ~ First_Op_Data_Saibo_No, data = dat, family = binomial)
summary(model)

```


#champagne and light champ

```{r}
library(ggplot2)
library(dplyr)

# Calculate proportion of champ pearls per donor
prop_data <- dat %>%
  group_by(First_Op_Data_Saibo_No) %>%
  summarise(
    n = n(),
    champ_rate = mean(Champ)
  )

# Bar plot
p_champ <- ggplot(prop_data, aes(x = First_Op_Data_Saibo_No, y = champ_rate)) +
  geom_col(fill = "#F7E7CE") +
  labs(
    x = "Saibo Donor ID",
    y = "Proportion of Champagne Pearls",
    title = "Proportion of Champagne Pearls by Saibo Donor"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_champ

```



#stacked plot

```{r}
library(dplyr)
library(stringr)
library(ggplot2)
library(scales)

# Start with your dataset
dat <- PearlOperationalData

# Clean and classify base colours (includes overtones)
dat <- dat %>%
  filter(!is.na(Pearl_Grading_Data_Colour),
         Pearl_Grading_Data_Colour != "") %>%
  mutate(
    base_colour = case_when(
      str_detect(Pearl_Grading_Data_Colour, regex("^Gold", ignore_case = TRUE)) ~ "Gold",
      str_detect(Pearl_Grading_Data_Colour, regex("^Silver", ignore_case = TRUE)) ~ "Silver",
      str_detect(Pearl_Grading_Data_Colour, regex("^White", ignore_case = TRUE)) ~ "White",
      str_detect(Pearl_Grading_Data_Colour, regex("^Cream", ignore_case = TRUE)) ~ "Cream",
      str_detect(Pearl_Grading_Data_Colour, regex("Champ", ignore_case = TRUE)) ~ "Champagne",
      TRUE ~ NA_character_
    ),
    First_Op_Data_Saibo_No = as.factor(First_Op_Data_Saibo_No)
  ) %>%
  filter(!is.na(base_colour))

# Ensure legend order
dat$base_colour <- factor(dat$base_colour,
                          levels = c("Gold", "Silver", "White", "Cream", "Champagne"))

# Count and calculate proportions per donor
stack_df <- dat %>%
  count(First_Op_Data_Saibo_No, base_colour, name = "n") %>%
  group_by(First_Op_Data_Saibo_No) %>%
  mutate(prop = n / sum(n)) %>%
  ungroup()

# 100% stacked bar plot with custom colours
ggplot(stack_df, aes(x = First_Op_Data_Saibo_No, y = prop, fill = base_colour)) +
  geom_col(width = 0.9) +
  scale_fill_manual(
    values = c(
      "Gold" = "#ffd700",
      "Silver" = "#696969",
      "White" = "#d3d3d3",
      "Cream" = "#fffacd",
      "Champagne" = "#ffa07a"
    )
  ) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    x = "Saibo Donor ID",
    y = "Pearl Colour Composition (%)",
    fill = "Base colour",
    title = "Pearl colour composition per Saibo donor (startswith grouping)"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

```




#coordflip()

```{r}
library(dplyr)
library(stringr)
library(ggplot2)
library(scales)

# Start with your dataset
dat <- PearlOperationalData

# Clean and classify base colours (includes overtones)
dat <- dat %>%
  filter(!is.na(Pearl_Grading_Data_Colour),
         Pearl_Grading_Data_Colour != "") %>%
  mutate(
    base_colour = case_when(
      str_detect(Pearl_Grading_Data_Colour, regex("^Gold", ignore_case = TRUE)) ~ "Gold",
      str_detect(Pearl_Grading_Data_Colour, regex("^Silver", ignore_case = TRUE)) ~ "Silver",
      str_detect(Pearl_Grading_Data_Colour, regex("^White", ignore_case = TRUE)) ~ "White",
      str_detect(Pearl_Grading_Data_Colour, regex("^Cream", ignore_case = TRUE)) ~ "Cream",
      str_detect(Pearl_Grading_Data_Colour, regex("Champ", ignore_case = TRUE)) ~ "Champagne",
      TRUE ~ NA_character_
    ),
    First_Op_Data_Saibo_No = as.factor(First_Op_Data_Saibo_No)
  ) %>%
  filter(!is.na(base_colour))

# Ensure legend order
dat$base_colour <- factor(dat$base_colour,
                          levels = c("Gold", "Silver", "White", "Cream", "Champagne"))

# Count and calculate proportions per donor
stack_df <- dat %>%
  count(First_Op_Data_Saibo_No, base_colour, name = "n") %>%
  group_by(First_Op_Data_Saibo_No) %>%
  mutate(prop = n / sum(n)) %>%
  ungroup()

# 100% stacked bar plot with custom colours and flipped axes
ggplot(stack_df, aes(x = First_Op_Data_Saibo_No, y = prop, fill = base_colour)) +
  geom_col(width = 0.9) +
  coord_flip() +
  scale_fill_manual(
    values = c(
       "Gold" = "#ffd700",
      "Silver" = "#696969",
      "White" = "#d3d3d3",
      "Cream" = "#fffacd",
      "Champagne" = "#ffa07a"
    )
  ) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    x = "Saibo Donor ID",
    y = "Pearl Colour Composition (%)",
    fill = "Base colour",
    title = "Pearl colour composition per Saibo donor (startswith grouping)"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 8),
    legend.position = "right"
  )

```


#original patchwork

```{r}

library(patchwork)
 
# Stack all vertically:
combined_plot <- p_champ / p_cream / p_white / p_silver / p_gold


# Show it
combined_plot
```







# 2. Fixed Effects

#First_Op_Data_DVH_mm
# gold + overtones
#not signif
```{r}
# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Gold vs Others
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)

# Remove rows with missing First_Op_Data_DVH_mm
dat <- dat[!is.na(dat$First_Op_Data_DVH_mm), ]

# Fit logistic regression: DVH vs Gold
model <- glm(Gold ~ First_Op_Data_DVH_mm, data = dat, family = binomial)

# Summary of model
summary(model)

```

#First_Op_Data_DVH_mm
#silver + overtones
#signif intercept// not signif
```{r}
# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Silver vs Others
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)

# Remove rows with missing First_Op_Data_DVH_mm
dat <- dat[!is.na(dat$First_Op_Data_DVH_mm), ]

# Fit logistic regression: DVH vs Silver
model <- glm(Silver ~ First_Op_Data_DVH_mm, data = dat, family = binomial)

# Summary of model
summary(model)

```


#First_Op_Data_DVH_mm
#white + overtones
#not signif

```{r}
# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: White vs Others
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)

# Remove rows with missing First_Op_Data_DVH_mm
dat <- dat[!is.na(dat$First_Op_Data_DVH_mm), ]

# Fit logistic regression: DVH vs White
model <- glm(White ~ First_Op_Data_DVH_mm, data = dat, family = binomial)

# Summary of model
summary(model)

```


#First_Op_Data_DVH_mm
#cream
#signif

```{r}
# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Cream vs Others
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)

# Remove rows with missing First_Op_Data_DVH_mm
dat <- dat[!is.na(dat$First_Op_Data_DVH_mm), ]

# Fit logistic regression: DVH vs White
model <- glm(Cream ~ First_Op_Data_DVH_mm, data = dat, family = binomial)

# Summary of model
summary(model)

```


#First_Op_Data_DVH_mm
#Champagne
#not signif

```{r}
# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Champ vs Others
dat$Champ <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# Remove rows with missing First_Op_Data_DVH_mm
dat <- dat[!is.na(dat$First_Op_Data_DVH_mm), ]

# Fit logistic regression: DVH vs White
model <- glm(Champ ~ First_Op_Data_DVH_mm, data = dat, family = binomial)

# Summary of model
summary(model)

```



# First_Op_Data_APW_mm
#gold + overtones
#not signif
```{r}

# Load dataset
dat <- PearlOperationalData

# Convert Colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove missing/blank colour values
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary variable for Gold pearls
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)

# Remove rows with missing APW values
dat <- dat[!is.na(dat$First_Op_Data_APW_mm), ]

# Fit logistic regression model
model <- glm(Gold ~ First_Op_Data_APW_mm, data = dat, family = binomial)

# Show model summary
summary(model)



```



# First_Op_Data_APW_mm
#silver + overtones
#signif intercept // not signif
```{r}

# Load dataset
dat <- PearlOperationalData

# Convert Colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove missing/blank colour values
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary variable for Silver pearls
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)

# Remove rows with missing APW values
dat <- dat[!is.na(dat$First_Op_Data_APW_mm), ]

# Fit logistic regression model
model <- glm(Silver ~ First_Op_Data_APW_mm, data = dat, family = binomial)

# Show model summary
summary(model)



```

# First_Op_Data_APW_mm
#white + overtones
#not signif
```{r}

# Load dataset
dat <- PearlOperationalData

# Convert Colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove missing/blank colour values
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary variable for White pearls
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)

# Remove rows with missing APW values
dat <- dat[!is.na(dat$First_Op_Data_APW_mm), ]

# Fit logistic regression model
model <- glm(White ~ First_Op_Data_APW_mm, data = dat, family = binomial)

# Show model summary
summary(model)



```

# First_Op_Data_APW_mm
#cream
#not signif
```{r}

# Load dataset
dat <- PearlOperationalData

# Convert Colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove missing/blank colour values
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary variable for Cream pearls
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)

# Remove rows with missing APW values
dat <- dat[!is.na(dat$First_Op_Data_APW_mm), ]

# Fit logistic regression model
model <- glm(Cream ~ First_Op_Data_APW_mm, data = dat, family = binomial)

# Show model summary
summary(model)



```

# First_Op_Data_APW_mm
#champ
# not signif
```{r}

# Load dataset
dat <- PearlOperationalData

# Convert Colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove missing/blank colour values
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary variable for Champ pearls
dat$Champ <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# Remove rows with missing APW values
dat <- dat[!is.na(dat$First_Op_Data_APW_mm), ]

# Fit logistic regression model
model <- glm(Champ ~ First_Op_Data_APW_mm, data = dat, family = binomial)

# Show model summary
summary(model)



```


## 

##gold 
#  First_Op_Data_Shell_Depth_mm
# not signif

```{r}

# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Gold vs Others
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)

# Remove rows with missing First_Op_Data_Shell_Depth_mm
dat <- dat[!is.na(dat$First_Op_Data_Shell_Depth_mm), ]

# Fit logistic regression: DVH vs Gold
model <- glm(Gold ~ First_Op_Data_Shell_Depth_mm, data = dat, family = binomial)

# Summary of model
summary(model)

```

#silver 
#First_Op_Data_Shell_Depth_mm
#not signif


```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Silver vs Others
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)

# Remove rows with missing First_Op_Data_Shell_Depth_mm
dat <- dat[!is.na(dat$First_Op_Data_Shell_Depth_mm), ]

# Fit logistic regression: DVH vs Silver
model <- glm(Silver ~ First_Op_Data_Shell_Depth_mm, data = dat, family = binomial)

# Summary of model
summary(model)

```

#white
#First_Op_Data_Shell_Depth_mm
#not signif
```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: White vs Others
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)

# Remove rows with missing First_Op_Data_Shell_Depth_mm
dat <- dat[!is.na(dat$First_Op_Data_Shell_Depth_mm), ]

# Fit logistic regression: DVH vs White
model <- glm(White ~ First_Op_Data_Shell_Depth_mm, data = dat, family = binomial)

# Summary of model
summary(model)

```

#cream
# First_Op_Data_Shell_Depth_mm
#not signif


```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Cream vs Others
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)

# Remove rows with missing First_Op_Data_Shell_Depth_mm
dat <- dat[!is.na(dat$First_Op_Data_Shell_Depth_mm), ]

# Fit logistic regression: DVH vs Cream
model <- glm(Cream ~ First_Op_Data_Shell_Depth_mm, data = dat, family = binomial)

# Summary of model
summary(model)

```


#champ
#First_Op_Data_Shell_Depth_mm
#not signif
```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Champ vs Others
dat$Champ <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# Remove rows with missing First_Op_Data_Shell_Depth_mm
dat <- dat[!is.na(dat$First_Op_Data_Shell_Depth_mm), ]

# Fit logistic regression: DVH vs Cream
model <- glm(Champ ~ First_Op_Data_Shell_Depth_mm, data = dat, family = binomial)

# Summary of model
summary(model)

```

## statistical test for shell weight vs binary colour 

##gold 
#First_Op_Data_Shell_Weight_g
#intercept signif// not signif

```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Gold vs Others
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)

# Remove rows with missing First_Op_Data_Shell_Weight_g
dat <- dat[!is.na(dat$First_Op_Data_Shell_Weight_g), ]

# Fit logistic regression: shell weight vs Gold
model <- glm(Gold ~ First_Op_Data_Shell_Weight_g, data = dat, family = binomial)

# Summary of model
summary(model)

```


##silver
#First_Op_Data_Shell_Weight_g
#intercept signif// not signif

```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Silver vs Others
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)

# Remove rows with missing First_Op_Data_Shell_Weight_g
dat <- dat[!is.na(dat$First_Op_Data_Shell_Weight_g), ]

# Fit logistic regression: shell weight vs Gold
model <- glm(Silver ~ First_Op_Data_Shell_Weight_g, data = dat, family = binomial)

# Summary of model
summary(model)

```

##white
#First_Op_Data_Shell_Weight_g
#not signif

```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: White vs Others
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)

# Remove rows with missing First_Op_Data_Shell_Weight_g
dat <- dat[!is.na(dat$First_Op_Data_Shell_Weight_g), ]

# Fit logistic regression: shell weight vs Gold
model <- glm(White ~ First_Op_Data_Shell_Weight_g, data = dat, family = binomial)

# Summary of model
summary(model)

```


##cream
#First_Op_Data_Shell_Weight_g
#intercept signif// not signif

```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Cream vs Others
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)

# Remove rows with missing First_Op_Data_Shell_Weight_g
dat <- dat[!is.na(dat$First_Op_Data_Shell_Weight_g), ]

# Fit logistic regression: shell weight vs Cream
model <- glm(Cream ~ First_Op_Data_Shell_Weight_g, data = dat, family = binomial)

# Summary of model
summary(model)

```

##champagne
#First_Op_Data_Shell_Weight_g
#intercept signif// not signif

```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: Champ vs Others
dat$Champ <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# Remove rows with missing First_Op_Data_Shell_Weight_g
dat <- dat[!is.na(dat$First_Op_Data_Shell_Weight_g), ]

# Fit logistic regression: shell weight vs Cream
model <- glm(Champ ~ First_Op_Data_Shell_Weight_g, data = dat, family = binomial)

# Summary of model
summary(model)

```




#gold
#First_Op_Data_Nacre_Lip_Colour_Round
#intercept signif// not signif

```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: gold vs Others
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)

# Remove rows with missing First_Op_Data_Nacre_Lip_Colour_Round
dat <- dat[!is.na(dat$First_Op_Data_Nacre_Lip_Colour_Round), ]

# Fit logistic regression: shell weight vs gold
model <- glm(Gold ~ First_Op_Data_Nacre_Lip_Colour_Round, data = dat, family = binomial)

# Summary of model
summary(model)

```



#silver
#First_Op_Data_Nacre_Lip_Colour_Round
#intercept signif// not signif

```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: silver vs Others
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)

# Remove rows with missing First_Op_Data_Nacre_Lip_Colour_Round
dat <- dat[!is.na(dat$First_Op_Data_Nacre_Lip_Colour_Round), ]

# Fit logistic regression: nacre lip colour host vs Silver
model <- glm(Silver ~ First_Op_Data_Nacre_Lip_Colour_Round, data = dat, family = binomial)

# Summary of model
summary(model)

```



#white
#First_Op_Data_Nacre_Lip_Colour_Round
#intercept signif// not signif

```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: silver vs Others
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)

# Remove rows with missing First_Op_Data_Nacre_Lip_Colour_Round
dat <- dat[!is.na(dat$First_Op_Data_Nacre_Lip_Colour_Round), ]

# Fit logistic regression: nacre lip colour host vs Silver
model <- glm(White ~ First_Op_Data_Nacre_Lip_Colour_Round, data = dat, family = binomial)

# Summary of model
summary(model)

```

#cream
#First_Op_Data_Nacre_Lip_Colour_Round
#intercept signif// not signif

```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: cream vs Others
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)

# Remove rows with missing First_Op_Data_Nacre_Lip_Colour_Round
dat <- dat[!is.na(dat$First_Op_Data_Nacre_Lip_Colour_Round), ]

# Fit logistic regression: nacre lip colour host vs cream
model <- glm(Cream ~ First_Op_Data_Nacre_Lip_Colour_Round, data = dat, family = binomial)

# Summary of model
summary(model)

```

#champ
#First_Op_Data_Nacre_Lip_Colour_Round
#intercept signif// not signif


```{r}



# Load your dataset
dat <- PearlOperationalData

# Convert colour to character
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Filter out blanks/missing
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary: champ vs Others
dat$Champ <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# Remove rows with missing First_Op_Data_Nacre_Lip_Colour_Round
dat <- dat[!is.na(dat$First_Op_Data_Nacre_Lip_Colour_Round), ]

# Fit logistic regression: nacre lip colour host vs champ
model <- glm(Champ ~ First_Op_Data_Nacre_Lip_Colour_Round, data = dat, family = binomial)

# Summary of model
summary(model)

```

#gold, silver, white, cream, champ
#First_Op_Data_Nacre_Lip_Colour_Flat
#intercept signif// not signif for all

```{r}
library(ggplot2)
library(dplyr)

# Load and clean data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$First_Op_Data_Nacre_Lip_Colour_Flat), ]

# Convert to factor
dat$First_Op_Data_Nacre_Lip_Colour_Flat <- factor(dat$First_Op_Data_Nacre_Lip_Colour_Flat)

# Create binary columns for each pearl colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)

# Fit logistic models
mod_gold <- glm(Gold ~ First_Op_Data_Nacre_Lip_Colour_Flat, data = dat, family = binomial)
mod_silver <- glm(Silver ~ First_Op_Data_Nacre_Lip_Colour_Flat, data = dat, family = binomial)
mod_white <- glm(White ~ First_Op_Data_Nacre_Lip_Colour_Flat, data = dat, family = binomial)
mod_cream <- glm(Cream ~ First_Op_Data_Nacre_Lip_Colour_Flat, data = dat, family = binomial)
mod_champ <- glm(Champ ~ First_Op_Data_Nacre_Lip_Colour_Flat, data = dat, family = binomial)

# GLM statistical tests
summary(mod_gold)   # Test: Does lip colour predict Gold pearl?
summary(mod_silver) # Test: Does lip colour predict Silver pearl?
summary(mod_white)  # Test: Does lip colour predict White pearl?
summary(mod_cream)  # Test: Does lip colour predict Cream pearl?
summary(mod_champ)  # Test: Does lip colour predict Champ pearl?

```


#gold, silver, white, cream, champ
#First_Op_Data_Nuclei_Size_mm
#some intercept signif// silver and cream signif


```{r}
library(ggplot2)
library(dplyr)

# Load and clean data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$First_Op_Data_Nuclei_Size_mm), ]

# Create binary columns for each colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)

# Fit logistic regression models
mod_gold <- glm(Gold ~ First_Op_Data_Nuclei_Size_mm, data = dat, family = binomial)
mod_silver <- glm(Silver ~ First_Op_Data_Nuclei_Size_mm, data = dat, family = binomial)
mod_white <- glm(White ~ First_Op_Data_Nuclei_Size_mm, data = dat, family = binomial)
mod_cream <- glm(Cream ~ First_Op_Data_Nuclei_Size_mm, data = dat, family = binomial)
mod_champ <- glm(Champ ~ First_Op_Data_Nuclei_Size_mm, data = dat, family = binomial)

# GLM summaries
cat("==== Gold ====\n")
print(summary(mod_gold))       # Tests if nuclei size affects probability of gold pearl
print(anova(mod_gold, test = "Chisq"))  # Likelihood ratio test

cat("==== Silver ====\n")
print(summary(mod_silver))
print(anova(mod_silver, test = "Chisq"))

cat("==== White ====\n")
print(summary(mod_white))
print(anova(mod_white, test = "Chisq"))

cat("==== Cream ====\n")
print(summary(mod_cream))
print(anova(mod_cream, test = "Chisq"))

cat("==== Champ ====\n")
print(summary(mod_champ))
print(anova(mod_champ, test = "Chisq"))

```

#gold, silver, white, cream, champ
#First_Op_Data_Saibo_Area
#some intercept signif // silver and white signif

```{r}
library(ggplot2)
library(dplyr)

# Load and clean data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$First_Op_Data_Saibo_Area), ]
dat$First_Op_Data_Saibo_Area <- as.factor(dat$First_Op_Data_Saibo_Area)

# Create binary outcome variables for each colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)

# Fit logistic regression models
mod_gold <- glm(Gold ~ First_Op_Data_Saibo_Area, data = dat, family = binomial)
mod_silver <- glm(Silver ~ First_Op_Data_Saibo_Area, data = dat, family = binomial)
mod_white <- glm(White ~ First_Op_Data_Saibo_Area, data = dat, family = binomial)
mod_cream <- glm(Cream ~ First_Op_Data_Saibo_Area, data = dat, family = binomial)
mod_champ <- glm(Champ ~ First_Op_Data_Saibo_Area, data = dat, family = binomial)

summary(glm(Gold ~ First_Op_Data_Saibo_Area, data = dat, family = binomial))
summary(glm(Silver ~ First_Op_Data_Saibo_Area, data = dat, family = binomial))
summary(glm(White ~ First_Op_Data_Saibo_Area, data = dat, family = binomial))
summary(glm(Cream ~ First_Op_Data_Saibo_Area, data = dat, family = binomial))
summary(glm(Champ ~ First_Op_Data_Saibo_Area, data = dat, family = binomial))



```

#Pearl_Harvest_Data_Days_of_Pearl_Culture
#champ signif
## statistical test
#Test if the proportion (rate) of a color changes with Days of Pearl Culture (continuous variable)
#Use logistic regression (generalized linear model, binomial family) for each color:

```{r}
# Example for Gold pearls: assuming Gold is binary 0/1 per pearl
glm_gold <- glm(Gold ~ Pearl_Harvest_Data_Days_of_Pearl_Culture, data = dat, family = binomial)
summary(glm_gold)
#This tests whether the odds of a pearl being Gold change with Days of Pearl Culture.

glm_silver <- glm(Silver ~ Pearl_Harvest_Data_Days_of_Pearl_Culture, data = dat, family = binomial)
summary(glm_silver)

glm_white <- glm(White ~ Pearl_Harvest_Data_Days_of_Pearl_Culture, data = dat, family = binomial)
summary(glm_white)

glm_cream <- glm(Cream ~ Pearl_Harvest_Data_Days_of_Pearl_Culture, data = dat, family = binomial)
summary(glm_cream)

glm_champ <- glm(Champ ~ Pearl_Harvest_Data_Days_of_Pearl_Culture, data = dat, family = binomial)
summary(glm_champ)


```

#gold, silver, white, cream, champ
#Pearl_Harvest_Data_DVH_mm
#some intercept signif// gold and white signif

```{r}
library(ggplot2)
library(dplyr)

# Load and prepare data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$Pearl_Harvest_Data_DVH_mm), ]

# Create binary columns for each colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)


# Logistic regression models per colour
mod_gold   <- glm(Gold ~ Pearl_Harvest_Data_DVH_mm, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Pearl_Harvest_Data_DVH_mm, data = dat, family = binomial)
mod_white  <- glm(White ~ Pearl_Harvest_Data_DVH_mm, data = dat, family = binomial)
mod_cream  <- glm(Cream ~ Pearl_Harvest_Data_DVH_mm, data = dat, family = binomial)
mod_champ  <- glm(Champ ~ Pearl_Harvest_Data_DVH_mm, data = dat, family = binomial)

# Display GLM summaries (coefficients, p-values, etc.)
summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)



```


#gold, silver, white, cream, champ
#Pearl_Harvest_Data_APW_mm
#gold signif

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Prepare data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$Pearl_Harvest_Data_APW_mm), ]  # Use APW instead of DVH

# Create binary columns for each colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)


# Fit GLMs for each colour vs APW (logistic regression)
mod_gold   <- glm(Gold ~ Pearl_Harvest_Data_APW_mm, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Pearl_Harvest_Data_APW_mm, data = dat, family = binomial)
mod_white  <- glm(White ~ Pearl_Harvest_Data_APW_mm, data = dat, family = binomial)
mod_cream  <- glm(Cream ~ Pearl_Harvest_Data_APW_mm, data = dat, family = binomial)
mod_champ  <- glm(Champ ~ Pearl_Harvest_Data_APW_mm, data = dat, family = binomial)

# Show GLM summaries (coefficients, p-values, etc.)
summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)



```


#gold, silver, white, cream, champ
#Pearl_Harvest_Data_Shell_Depth_mm
#some intercept signif// not signif for all

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Prepare data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$Pearl_Harvest_Data_Shell_Depth_mm), ]  # Use Shell Depth

# Create binary columns for each colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)

# Logistic regression models
mod_gold   <- glm(Gold ~ Pearl_Harvest_Data_Shell_Depth_mm, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Pearl_Harvest_Data_Shell_Depth_mm, data = dat, family = binomial)
mod_white  <- glm(White ~ Pearl_Harvest_Data_Shell_Depth_mm, data = dat, family = binomial)
mod_cream  <- glm(Cream ~ Pearl_Harvest_Data_Shell_Depth_mm, data = dat, family = binomial)
mod_champ  <- glm(Champ ~ Pearl_Harvest_Data_Shell_Depth_mm, data = dat, family = binomial)

# View model summaries
summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)
```

#gold, silver, white, cream, champ
#Pearl_Harvest_Data_Shell_Weight_g
# some intercept signif// gold and white signif

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Prepare data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$Pearl_Harvest_Data_Shell_Weight_g), ]  # Use Shell Weight

# Create binary columns for each colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)

# Fit logistic regression models
mod_gold <- glm(Gold ~ Pearl_Harvest_Data_Shell_Weight_g, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Pearl_Harvest_Data_Shell_Weight_g, data = dat, family = binomial)
mod_white <- glm(White ~ Pearl_Harvest_Data_Shell_Weight_g, data = dat, family = binomial)
mod_cream <- glm(Cream ~ Pearl_Harvest_Data_Shell_Weight_g, data = dat, family = binomial)
mod_champ <- glm(Champ ~ Pearl_Harvest_Data_Shell_Weight_g, data = dat, family = binomial)

# Get summaries of each model (includes p-values)
summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)


```


##donor
# gold, silver, white, cream, champ
# Matched_Donor_Data_DVH_mm
# some intercept signif // cream signif

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Prepare data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$Matched_Donor_Data_DVH_mm), ]  # Use Donor DVH

# Create binary columns for each colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)


# Fit logistic regression models
mod_gold <- glm(Gold ~ Matched_Donor_Data_DVH_mm, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Matched_Donor_Data_DVH_mm, data = dat, family = binomial)
mod_white <- glm(White ~ Matched_Donor_Data_DVH_mm, data = dat, family = binomial)
mod_cream <- glm(Cream ~ Matched_Donor_Data_DVH_mm, data = dat, family = binomial)
mod_champ <- glm(Champ ~ Matched_Donor_Data_DVH_mm, data = dat, family = binomial)

summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)


```

#gold, silver, white, cream, champ
#Matched_Donor_Data_APW_mm
#some intercept signif// not signif for all


```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Prepare data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$Matched_Donor_Data_APW_mm), ]  # Use Donor APW

# Create binary columns for each colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)

# Fit GLMs
mod_gold   <- glm(Gold ~ Matched_Donor_Data_APW_mm, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Matched_Donor_Data_APW_mm, data = dat, family = binomial)
mod_white  <- glm(White ~ Matched_Donor_Data_APW_mm, data = dat, family = binomial)
mod_cream  <- glm(Cream ~ Matched_Donor_Data_APW_mm, data = dat, family = binomial)
mod_champ  <- glm(Champ ~ Matched_Donor_Data_APW_mm, data = dat, family = binomial)

summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)
```



#gold, silver, white, cream, champ
#Matched_Donor_Data_Shell_Depth_mm
#some intercept signif// not signif for all

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Prepare data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$Matched_Donor_Data_Shell_Depth_mm), ]  # Use Donor Shell Depth

# Create binary columns for each colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)


# Fit logistic models for each colour
mod_gold   <- glm(Gold ~ Matched_Donor_Data_Shell_Depth_mm, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Matched_Donor_Data_Shell_Depth_mm, data = dat, family = binomial)
mod_white  <- glm(White ~ Matched_Donor_Data_Shell_Depth_mm, data = dat, family = binomial)
mod_cream  <- glm(Cream ~ Matched_Donor_Data_Shell_Depth_mm, data = dat, family = binomial)
mod_champ  <- glm(Champ ~ Matched_Donor_Data_Shell_Depth_mm, data = dat, family = binomial)



summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)

```


#gold, silver, white, cream, champ
#Matched_Donor_Data_Shell_Weight_g
#some intercept signif// cream signif

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Prepare data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$Matched_Donor_Data_Shell_Weight_g), ]  # Use Donor Shell Weight

# Create binary columns for each colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)


# Fit logistic regression models
mod_gold   <- glm(Gold   ~ Matched_Donor_Data_Shell_Weight_g, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Matched_Donor_Data_Shell_Weight_g, data = dat, family = binomial)
mod_white  <- glm(White  ~ Matched_Donor_Data_Shell_Weight_g, data = dat, family = binomial)
mod_cream  <- glm(Cream  ~ Matched_Donor_Data_Shell_Weight_g, data = dat, family = binomial)
mod_champ  <- glm(Champ  ~ Matched_Donor_Data_Shell_Weight_g, data = dat, family = binomial)

summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)


```

#gold, silver, white, cream, champ
#Matched_Donor_Data_Nacre_lip_colour_Round
#ISSUES AS THE COLOURS ARE TOO SKEWED

```{r}
library(ggplot2)
library(dplyr)

# Load and clean data
dat <- PearlOperationalData
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]
dat <- dat[!is.na(dat$Matched_Donor_Data_Nacre_lip_colour_Round), ]

# Convert to factor
#dat$Matched_Donor_Data_Nacre_lip_colour_Round <- #factor(dat$Matched_Donor_Data_Nacre_lip_colour_Round)

# Create binary columns for each pearl colour
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
dat$Champ <- ifelse(grepl("Champ", dat$Pearl_Grading_Data_Colour), 1, 0)



# Fit logistic regression models
mod_gold   <- glm(Gold   ~ Matched_Donor_Data_Nacre_lip_colour_Round, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Matched_Donor_Data_Nacre_lip_colour_Round, data = dat, family = binomial)
mod_white  <- glm(White  ~ Matched_Donor_Data_Nacre_lip_colour_Round, data = dat, family = binomial)
mod_cream  <- glm(Cream  ~ Matched_Donor_Data_Nacre_lip_colour_Round, data = dat, family = binomial)
mod_champ  <- glm(Champ  ~ Matched_Donor_Data_Nacre_lip_colour_Round, data = dat, family = binomial)

summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)


# Counts
table(dat$Matched_Donor_Data_Nacre_lip_colour_Round)

# Counts with proportions
prop.table(table(dat$Matched_Donor_Data_Nacre_lip_colour_Round)) * 100


library(ggplot2)

ggplot(dat, aes(x = Matched_Donor_Data_Nacre_lip_colour_Round)) +
  geom_bar(fill = "steelblue") +
  labs(
    x = "Nacre Lip Colour (Donor)",
    y = "Count",
    title = "Distribution of Donor Nacre Lip Colours"
  ) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```


#gold, silver, white, cream, champ
#Matched_Donor_Data_Nacre_lip_colour_Round
#those with Gr (green) is usually gold, cream // gold, white, cream, champ signif



```{r}
library(dplyr)
library(ggplot2)

# Load and clean data
dat <- PearlOperationalData

# Keep only rows with valid colour and lip colour
dat <- dat %>%
  filter(
    !is.na(Pearl_Grading_Data_Colour),
    Pearl_Grading_Data_Colour != "",
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    Matched_Donor_Data_Nacre_lip_colour_Round != ""
  )

# Merge rare lip colour levels into "Other"
dat$Matched_Donor_Data_Nacre_lip_colour_Round <- as.character(dat$Matched_Donor_Data_Nacre_lip_colour_Round)
dat$Matched_Donor_Data_Nacre_lip_colour_Round <- ifelse(
  dat$Matched_Donor_Data_Nacre_lip_colour_Round %in% c("WY", "LGr"),
  "Other",
  dat$Matched_Donor_Data_Nacre_lip_colour_Round
)

# Convert to factor and set reference level to "S"
dat$Matched_Donor_Data_Nacre_lip_colour_Round <- factor(dat$Matched_Donor_Data_Nacre_lip_colour_Round)
if ("S" %in% levels(dat$Matched_Donor_Data_Nacre_lip_colour_Round)) {
  dat$Matched_Donor_Data_Nacre_lip_colour_Round <- relevel(dat$Matched_Donor_Data_Nacre_lip_colour_Round, ref = "S")
}

# View updated distribution of lip colours
print(table(dat$Matched_Donor_Data_Nacre_lip_colour_Round))

# Create binary outcome variables for each colour (case-insensitive)
is_start <- function(x, prefix) grepl(paste0("^", prefix), x, ignore.case = TRUE)
dat$Gold   <- as.integer(is_start(dat$Pearl_Grading_Data_Colour, "Gold"))
dat$Silver <- as.integer(is_start(dat$Pearl_Grading_Data_Colour, "Silver"))
dat$White  <- as.integer(is_start(dat$Pearl_Grading_Data_Colour, "White"))
dat$Cream  <- as.integer(is_start(dat$Pearl_Grading_Data_Colour, "Cream"))
dat$Champ  <- as.integer(grepl("Champ", dat$Pearl_Grading_Data_Colour, ignore.case = TRUE))

# Fit logistic regression models
mod_gold   <- glm(Gold   ~ Matched_Donor_Data_Nacre_lip_colour_Round, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Matched_Donor_Data_Nacre_lip_colour_Round, data = dat, family = binomial)
mod_white  <- glm(White  ~ Matched_Donor_Data_Nacre_lip_colour_Round, data = dat, family = binomial)
mod_cream  <- glm(Cream  ~ Matched_Donor_Data_Nacre_lip_colour_Round, data = dat, family = binomial)
mod_champ  <- glm(Champ  ~ Matched_Donor_Data_Nacre_lip_colour_Round, data = dat, family = binomial)

# Summarise models
summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)

```




#gold, silver, white, cream, champ
#Matched_Donor_Data_Nacre_lip_colour_Flat
#some intercepts are signif// gold, white, cream, champ signif; Silver and White do not have Gr


```{r}
library(dplyr)
library(ggplot2)

# Load and clean data
dat <- PearlOperationalData

# Keep only rows with valid pearl colour and flat lip colour
dat <- dat %>%
  filter(
    !is.na(Pearl_Grading_Data_Colour),
    Pearl_Grading_Data_Colour != "",
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    Matched_Donor_Data_Nacre_lip_colour_Flat != ""
  )

# Merge rare flat lip colour levels into "Other"
dat$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.character(dat$Matched_Donor_Data_Nacre_lip_colour_Flat)
dat$Matched_Donor_Data_Nacre_lip_colour_Flat <- ifelse(
  dat$Matched_Donor_Data_Nacre_lip_colour_Flat %in% c("WY", "LGr"),
  "Other",
  dat$Matched_Donor_Data_Nacre_lip_colour_Flat
)

# Convert to factor and set reference level to "S"
dat$Matched_Donor_Data_Nacre_lip_colour_Flat <- factor(dat$Matched_Donor_Data_Nacre_lip_colour_Flat)
if ("S" %in% levels(dat$Matched_Donor_Data_Nacre_lip_colour_Flat)) {
  dat$Matched_Donor_Data_Nacre_lip_colour_Flat <- relevel(dat$Matched_Donor_Data_Nacre_lip_colour_Flat, ref = "S")
}

# View updated distribution of lip colours
print(table(dat$Matched_Donor_Data_Nacre_lip_colour_Flat))

# Create binary outcome variables for each colour (case-insensitive)
is_start <- function(x, prefix) grepl(paste0("^", prefix), x, ignore.case = TRUE)
dat$Gold   <- as.integer(is_start(dat$Pearl_Grading_Data_Colour, "Gold"))
dat$Silver <- as.integer(is_start(dat$Pearl_Grading_Data_Colour, "Silver"))
dat$White  <- as.integer(is_start(dat$Pearl_Grading_Data_Colour, "White"))
dat$Cream  <- as.integer(is_start(dat$Pearl_Grading_Data_Colour, "Cream"))
dat$Champ  <- as.integer(grepl("Champ", dat$Pearl_Grading_Data_Colour, ignore.case = TRUE))

# Fit logistic regression models
mod_gold   <- glm(Gold   ~ Matched_Donor_Data_Nacre_lip_colour_Flat, data = dat, family = binomial)
mod_silver <- glm(Silver ~ Matched_Donor_Data_Nacre_lip_colour_Flat, data = dat, family = binomial)
mod_white  <- glm(White  ~ Matched_Donor_Data_Nacre_lip_colour_Flat, data = dat, family = binomial)
mod_cream  <- glm(Cream  ~ Matched_Donor_Data_Nacre_lip_colour_Flat, data = dat, family = binomial)
mod_champ  <- glm(Champ  ~ Matched_Donor_Data_Nacre_lip_colour_Flat, data = dat, family = binomial)

# Summarise models
summary(mod_gold)
summary(mod_silver)
summary(mod_white)
summary(mod_cream)
summary(mod_champ)

```










# 3. Traditional Model (Binary)

## TRADITIONAL HERITABILITY ESTIMATES AND ESTIMATED BREEDING VALUES

#HOST GOLD OLD

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data

#host_dat <- read_csv("host_id.csv")
host_dat <- host_id

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)

# 4. Ensure shell metrics are numeric
host_dat$Pearl_Harvest_Data_DVH_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_DVH_mm)
host_dat$Pearl_Harvest_Data_APW_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_APW_mm)
host_dat$Pearl_Harvest_Data_Shell_Weight_g <- as.numeric(host_dat$Pearl_Harvest_Data_Shell_Weight_g)

# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(Pearl_Harvest_Data_APW_mm),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for Gold (binary trait)
mod.ind <- asreml(
  fixed = Gold ~ Pearl_Harvest_Data_DVH_mm + Pearl_Harvest_Data_APW_mm + Pearl_Harvest_Data_Shell_Weight_g,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))


# Latent scale tells you the heritability on a theoretical continuous trait that gives rise to the binary outcome.

# Observed scale tells you how much of the 0/1 variation is due to genetics — and is usually much lower, especially when the trait is rare

# --- Extract variance components ---
vc     <- summary(mod.ind)$varcomp
Va     <- vc["vm(host_id, ainv)", "component"]     # Additive genetic variance
SE_Va  <- vc["vm(host_id, ainv)", "std.error"]     # Standard error of Va
Ve     <- (pi^2)/3                                        # Residual variance for logistic models

# --- Latent-scale heritability ---
h2_latent     <- Va / (Va + Ve)
dVa           <- Ve / (Va + Ve)^2                 # Derivative for delta method
SE_h2_latent  <- SE_Va * dVa

cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")

# --- Observed-scale heritability ---
p      <- mean(host_dat_clean$Gold, na.rm = TRUE)  # Trait prevalence
z      <- qnorm(p)
phi_z  <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs    <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_obs, "\n")

# --- Summary table of heritability and standard errors ---
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)


# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

#BLUP$prob_gold

```


HOST ID2 NEW GOLD TRADITIONAL BINARY 
#low bc of p <- mean(host_dat_clean$Gold)

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- read_csv("host_id2.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. Ensure shell metrics are numeric
host_dat$Pearl_Harvest_Data_DVH_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_DVH_mm)
host_dat$Pearl_Harvest_Data_APW_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_APW_mm)
host_dat$Pearl_Harvest_Data_Shell_Weight_g <- as.numeric(host_dat$Pearl_Harvest_Data_Shell_Weight_g)

host_dat$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(host_dat$Matched_Donor_Data_Nacre_lip_colour_Round)

host_dat$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.factor(host_dat$Matched_Donor_Data_Nacre_lip_colour_Flat)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(Pearl_Harvest_Data_APW_mm),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Gold ~ Pearl_Harvest_Data_DVH_mm + Pearl_Harvest_Data_APW_mm + Pearl_Harvest_Data_Shell_Weight_g + Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update model and extract variance components
mod.ind <- update(mod.ind)

vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))



vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Gold)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```



# HOST SILVER OLD better h2

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- host_id

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)
host_dat$First_Op_Data_Saibo_Area    <- as.factor(host_dat$First_Op_Data_Saibo_Area)

# 4. Ensure shell metrics are numeric
host_dat$First_Op_Data_Nuclei_Size_mm         <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)


# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(First_Op_Data_Saibo_Area),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for Silver (binary trait)
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm + First_Op_Data_Saibo_Area,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))


# calculate heritability on the observed scale from your animal model for a binary trait. This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).


# Latent scale tells you the heritability on a theoretical continuous trait that gives rise to the binary outcome.

# Observed scale tells you how much of the 0/1 variation is due to genetics — and is usually much lower, especially when the trait is rare

# --- Extract variance components ---
vc     <- summary(mod.ind)$varcomp
Va     <- vc["vm(host_id, ainv)", "component"]     # Additive genetic variance
SE_Va  <- vc["vm(host_id, ainv)", "std.error"]     # Standard error of Va
Ve     <- (pi^2)/3                                      # Residual variance for logistic models

# --- Latent-scale heritability ---
h2_latent     <- Va / (Va + Ve)
dVa           <- Ve / (Va + Ve)^2                 # Derivative for delta method
SE_h2_latent  <- SE_Va * dVa

cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")

# --- Observed-scale heritability ---
p      <- mean(host_dat_clean$Silver, na.rm = TRUE)  # Trait prevalence
z      <- qnorm(p)
phi_z  <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs    <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_obs, "\n")

# --- Summary table of heritability and standard errors ---
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)


```


NEW HOST SILVER 

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <-  read_csv("host_id2.csv")

# 2. Rename and factor columns
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    Gold   = ifelse(startsWith(Pearl_Grading_Data_Colour, "Gold"), 1, 0),
    Silver = ifelse(startsWith(Pearl_Grading_Data_Colour, "Silver"), 1, 0),
    White  = ifelse(startsWith(Pearl_Grading_Data_Colour, "White"), 1, 0),
    Cream  = ifelse(startsWith(Pearl_Grading_Data_Colour, "Cream"), 1, 0),
    Champ  = ifelse(startsWith(Pearl_Grading_Data_Colour, "Champ"), 1, 0),
    
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire),
    First_Op_Data_Saibo_Area = as.factor(First_Op_Data_Saibo_Area),
    Matched_Donor_Data_Nacre_lip_colour_Round = as.factor(Matched_Donor_Data_Nacre_lip_colour_Round),
    Matched_Donor_Data_Nacre_lip_colour_Flat  = as.factor(Matched_Donor_Data_Nacre_lip_colour_Flat),
    
    First_Op_Data_Nuclei_Size_mm = as.numeric(First_Op_Data_Nuclei_Size_mm)
  )

# 3. Remove rows with missing data
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(First_Op_Data_Saibo_Area),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(host_id)
  )

# 4. Prepare pedigree and inverse matrix
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 5. Fit ASReml binary model for Silver
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm + First_Op_Data_Saibo_Area +
    Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 6. Update model twice to ensure convergence
mod.ind <- update(mod.ind)
mod.ind <- update(mod.ind)

vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 7. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# 8. Heritability estimation
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Residual variance for logistic model

# Latent scale
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale
p <- mean(host_dat_clean$Silver)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))





# 9. Print heritability estimates
cat("Heritability (latent scale):       ", round(h2_latent, 4), "\n")
cat("Standard Error (latent scale):     ", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):     ", round(h2_obs, 4), "\n")
cat("Standard Error (observed scale):   ", round(SE_obs, 4), "\n")

# 10. Summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)
print(herit_summary)

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


#low bc the of p <- mean(host_dat_clean$Gold)  error
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- read_csv("host_id2.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. Ensure shell metrics are numeric
host_dat$Pearl_Harvest_Data_DVH_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_DVH_mm)
host_dat$Pearl_Harvest_Data_APW_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_APW_mm)
host_dat$Pearl_Harvest_Data_Shell_Weight_g <- as.numeric(host_dat$Pearl_Harvest_Data_Shell_Weight_g)

host_dat$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(host_dat$Matched_Donor_Data_Nacre_lip_colour_Round)

host_dat$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.factor(host_dat$Matched_Donor_Data_Nacre_lip_colour_Flat)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(Pearl_Harvest_Data_APW_mm),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Silver ~ Pearl_Harvest_Data_DVH_mm + Pearl_Harvest_Data_APW_mm + Pearl_Harvest_Data_Shell_Weight_g + Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update model and extract variance components
mod.ind <- update(mod.ind)

vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))



vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Gold)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```







#test but h2 still high
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- host_id2

# 2. Rename and recode columns
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    Gold   = ifelse(startsWith(Pearl_Grading_Data_Colour, "Gold"), 1, 0),
    Silver = ifelse(startsWith(Pearl_Grading_Data_Colour, "Silver"), 1, 0),
    White  = ifelse(startsWith(Pearl_Grading_Data_Colour, "White"), 1, 0),
    Cream  = ifelse(startsWith(Pearl_Grading_Data_Colour, "Cream"), 1, 0),
    Champ  = ifelse(startsWith(Pearl_Grading_Data_Colour, "Champ"), 1, 0),
    
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire),
    
    First_Op_Data_Saibo_Area = as.factor(First_Op_Data_Saibo_Area),
    Matched_Donor_Data_Nacre_lip_colour_Round = as.factor(Matched_Donor_Data_Nacre_lip_colour_Round),
    Matched_Donor_Data_Nacre_lip_colour_Flat  = as.factor(Matched_Donor_Data_Nacre_lip_colour_Flat),
    
    First_Op_Data_Nuclei_Size_mm = as.numeric(First_Op_Data_Nuclei_Size_mm),
    Pearl_Harvest_Data_DVH_mm = as.numeric(Pearl_Harvest_Data_DVH_mm),
    Pearl_Harvest_Data_APW_mm = as.numeric(Pearl_Harvest_Data_APW_mm),
    Pearl_Harvest_Data_Shell_Weight_g = as.numeric(Pearl_Harvest_Data_Shell_Weight_g)
  )

# 3. Remove rows with missing data in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(First_Op_Data_Saibo_Area),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(Pearl_Harvest_Data_APW_mm),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(host_id)
  )

# 4. Prepare pedigree and inverse matrix
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 5. Fit ASReml binary model for Silver (with biologically relevant fixed effects)
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm + First_Op_Data_Saibo_Area +
    Pearl_Harvest_Data_DVH_mm + Pearl_Harvest_Data_APW_mm + Pearl_Harvest_Data_Shell_Weight_g +
    Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 6. Update model twice to ensure convergence
mod.ind <- update(mod.ind)
mod.ind <- update(mod.ind)

# Optional: Vpredict latent-scale heritability (for double-checking)
vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 7. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# 8. Heritability calculations
Va     <- vc["vm(host_id, ainv)", "component"]
SE_Va  <- vc["vm(host_id, ainv)", "std.error"]
Ve     <- (pi^2) / 3  # Logistic residual variance

# --- Latent scale heritability ---
h2_latent     <- Va / (Va + Ve)
dVa           <- Ve / (Va + Ve)^2
SE_h2_latent  <- SE_Va * dVa

# --- Observed scale heritability ---
p      <- mean(host_dat_clean$Silver)
z      <- qnorm(p)
phi_z  <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 9. Output heritability estimates
cat("Heritability (latent scale):       ", round(h2_latent, 4), "\n")
cat("Standard Error (latent scale):     ", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):     ", round(h2_obs, 4), "\n")
cat("Standard Error (observed scale):   ", round(SE_obs, 4), "\n")

# 10. Summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)
print(herit_summary)

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```
















```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- read_csv("host_id2.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. Ensure shell metrics are numeric
host_dat$Pearl_Harvest_Data_DVH_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_DVH_mm)
host_dat$Pearl_Harvest_Data_APW_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_APW_mm)
host_dat$Pearl_Harvest_Data_Shell_Weight_g <- as.numeric(host_dat$Pearl_Harvest_Data_Shell_Weight_g)

host_dat$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(host_dat$Matched_Donor_Data_Nacre_lip_colour_Round)
host_dat$Matched_Donor_Data_Nacre_lip_colour_Flat  <- as.factor(host_dat$Matched_Donor_Data_Nacre_lip_colour_Flat)

# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(Pearl_Harvest_Data_APW_mm),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Silver
mod.ind <- asreml(
  fixed = Silver ~ Pearl_Harvest_Data_DVH_mm + Pearl_Harvest_Data_APW_mm + Pearl_Harvest_Data_Shell_Weight_g + Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update model and extract variance components
mod.ind <- update(mod.ind)

vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Silver)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```




# HOST WHITE

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#host_dat <- read_csv("host_id.csv")
host_dat <- host_id

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)
host_dat$First_Op_Data_Saibo_Area    <- as.factor(host_dat$First_Op_Data_Saibo_Area)

# 4. Ensure shell metrics are numeric
host_dat$Pearl_Harvest_Data_DVH_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_DVH_mm)
host_dat$Pearl_Harvest_Data_Shell_Weight_g         <- as.numeric(host_dat$Pearl_Harvest_Data_Shell_Weight_g)

# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(First_Op_Data_Saibo_Area),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for White (binary trait)
mod.ind <- asreml(
  fixed = White ~ Pearl_Harvest_Data_DVH_mm + First_Op_Data_Saibo_Area + Pearl_Harvest_Data_Shell_Weight_g,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)


# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# calculate heritability on the observed scale from your animal model for a binary trait. This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).


# Latent scale tells you the heritability on a theoretical continuous trait that gives rise to the binary outcome.

# Observed scale tells you how much of the 0/1 variation is due to genetics — and is usually much lower, especially when the trait is rare

# --- Extract variance components ---
vc     <- summary(mod.ind)$varcomp
Va     <- vc["vm(host_id, ainv)", "component"]     # Additive genetic variance
SE_Va  <- vc["vm(host_id, ainv)", "std.error"]     # Standard error of Va
Ve     <- (pi^2)/3                                        # Residual variance for logistic models

# --- Latent-scale heritability ---
h2_latent     <- Va / (Va + Ve)
dVa           <- Ve / (Va + Ve)^2                 # Derivative for delta method
SE_h2_latent  <- SE_Va * dVa

cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")

# --- Observed-scale heritability ---
p      <- mean(host_dat_clean$White, na.rm = TRUE)  # Trait prevalence
z      <- qnorm(p)
phi_z  <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs    <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_obs, "\n")

# --- Summary table of heritability and standard errors ---
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)


# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)



```



NEW HOST WHITE
```{r}

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- host_id2  # Already loaded in your environment

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Rename pedigree columns
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  )

# 4. Convert necessary columns to correct types
host_dat <- host_dat %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire),
    First_Op_Data_Saibo_Area = as.factor(First_Op_Data_Saibo_Area),
    Matched_Donor_Data_Nacre_lip_colour_Round = as.factor(Matched_Donor_Data_Nacre_lip_colour_Round),
    Matched_Donor_Data_Nacre_lip_colour_Flat  = as.factor(Matched_Donor_Data_Nacre_lip_colour_Flat),
    Pearl_Harvest_Data_DVH_mm = as.numeric(Pearl_Harvest_Data_DVH_mm),
    Pearl_Harvest_Data_Shell_Weight_g = as.numeric(Pearl_Harvest_Data_Shell_Weight_g)
  )

# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(First_Op_Data_Saibo_Area),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))
ainv <- ainverse(pedind)

# 7. Fit animal model for White (binary trait)
mod.ind <- asreml(
  fixed = White ~ Pearl_Harvest_Data_DVH_mm + First_Op_Data_Saibo_Area +
    Pearl_Harvest_Data_Shell_Weight_g +
    Matched_Donor_Data_Nacre_lip_colour_Round +
    Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update model twice to ensure convergence
mod.ind <- update(mod.ind)
mod.ind <- update(mod.ind)

vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 9. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# --- Heritability Estimation ---
Va    <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve    <- (pi^2) / 3  # Residual variance for logistic models

# Latent-scale heritability
h2_latent    <- Va / (Va + Ve)
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed-scale heritability
p      <- mean(host_dat_clean$White, na.rm = TRUE)
z      <- qnorm(p)
phi_z  <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print heritability estimates
cat("Heritability (latent scale):     ", round(h2_latent, 4), "\n")
cat("Standard Error (latent scale):   ", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):   ", round(h2_obs, 4), "\n")
cat("Standard Error (observed scale): ", round(SE_obs, 4), "\n")

# 10. Summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)
print(herit_summary)

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)
```




# HOST CREAM  old

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data

host_dat <- host_id

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)

# 4. Ensure predictors are numeric
host_dat$First_Op_Data_DVH_mm         <- as.numeric(host_dat$First_Op_Data_DVH_mm)
host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)

# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_DVH_mm),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))
ainv <- ainverse(pedind)


# 8. Fit animal model for Cream (binary trait)
mod.ind <- asreml(
  fixed    = Cream ~ First_Op_Data_DVH_mm + First_Op_Data_Nuclei_Size_mm,
  random   = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data     = host_dat_clean,
  family   = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)
mod.ind <- update.asreml(mod.ind)
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)


# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# Latent scale tells you the heritability on a theoretical continuous trait that gives rise to the binary outcome.

# Observed scale tells you how much of the 0/1 variation is due to genetics — and is usually much lower, especially when the trait is rare

# --- Extract variance components ---
vc     <- summary(mod.ind)$varcomp
Va     <- vc["vm(host_id, ainv)", "component"]     # Additive genetic variance
SE_Va  <- vc["vm(host_id, ainv)", "std.error"]     # Standard error of Va
Ve     <- (pi^2)/3                                       # Residual variance for logistic models

# --- Latent-scale heritability ---
h2_latent     <- Va / (Va + Ve)
dVa           <- Ve / (Va + Ve)^2                 # Derivative for delta method
SE_h2_latent  <- SE_Va * dVa

cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")

# --- Observed-scale heritability ---
p      <- mean(host_dat_clean$Cream, na.rm = TRUE)  # Trait prevalence
z      <- qnorm(p)
phi_z  <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs    <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_obs, "\n")

# --- Summary table of heritability and standard errors ---
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$host_id <- rownames(BLUP)
head(BLUP)



```





#NEW HOST CREAM  

```{r}

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- host_id2

# 2. Create binary colour traits and format variables
host_dat <- host_dat %>%
  mutate(
    Gold   = ifelse(startsWith(Pearl_Grading_Data_Colour, "Gold"), 1, 0),
    Silver = ifelse(startsWith(Pearl_Grading_Data_Colour, "Silver"), 1, 0),
    White  = ifelse(startsWith(Pearl_Grading_Data_Colour, "White"), 1, 0),
    Cream  = ifelse(startsWith(Pearl_Grading_Data_Colour, "Cream"), 1, 0),
    Champ  = ifelse(startsWith(Pearl_Grading_Data_Colour, "Champ"), 1, 0)
  ) %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam     = host_Dam,
    Sire    = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire),
    Matched_Donor_Data_Nacre_lip_colour_Round = as.factor(Matched_Donor_Data_Nacre_lip_colour_Round),
    Matched_Donor_Data_Nacre_lip_colour_Flat  = as.factor(Matched_Donor_Data_Nacre_lip_colour_Flat),
    First_Op_Data_DVH_mm         = as.numeric(First_Op_Data_DVH_mm),
    First_Op_Data_Nuclei_Size_mm = as.numeric(First_Op_Data_Nuclei_Size_mm),
    Matched_Donor_Data_Shell_Weight_g = as.numeric(Matched_Donor_Data_Shell_Weight_g),
    Matched_Donor_Data_DVH_mm        = as.numeric(Matched_Donor_Data_DVH_mm)
  )

# 3. Filter for complete cases
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_DVH_mm),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(Matched_Donor_Data_Shell_Weight_g),
    !is.na(Matched_Donor_Data_DVH_mm),
    !is.na(host_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 4. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))
ainv <- ainverse(pedind)

# 5. Fit ASReml animal model for Cream (binary trait)
mod.ind <- asreml(
  fixed = Cream ~ 
    First_Op_Data_DVH_mm +
    First_Op_Data_Nuclei_Size_mm +
    Matched_Donor_Data_Nacre_lip_colour_Round +
    Matched_Donor_Data_Nacre_lip_colour_Flat +
    Matched_Donor_Data_Shell_Weight_g +
    Matched_Donor_Data_DVH_mm,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 6. Update model for convergence
mod.ind <- update(mod.ind)
mod.ind <- update(mod.ind)

vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))


# 7. Extract variance components
vc     <- summary(mod.ind)$varcomp
Va     <- vc["vm(host_id, ainv)", "component"]
SE_Va  <- vc["vm(host_id, ainv)", "std.error"]
Ve     <- (pi^2) / 3  # Fixed residual variance for logit link

# 8. Heritability (latent scale)
h2_latent    <- Va / (Va + Ve)
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 9. Heritability (observed scale)
p     <- mean(host_dat_clean$Cream, na.rm = TRUE)
z     <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 10. Output results
cat("Heritability (latent scale):     ", round(h2_latent, 4), "\n")
cat("Standard Error (latent scale):   ", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):   ", round(h2_obs, 4), "\n")
cat("Standard Error (observed scale): ", round(SE_obs, 4), "\n")

# 11. Summary table
herit_summary <- data.frame(
  Scale        = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error    = c(SE_h2_latent, SE_obs)
)
print(herit_summary)

# 12. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$host_id <- gsub("vm\\(host_id, ainv\\)_", "", rownames(BLUP))
head(BLUP)




```


# HOST cHAMPAGNE

```{r}

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- host_id

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture    <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)




# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for champ (binary trait)
mod.ind <- asreml(
  fixed = Champ ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# calculate heritability on the observed scale from your animal model for a binary trait. This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).

# Latent scale tells you the heritability on a theoretical continuous trait that gives rise to the binary outcome.

# Observed scale tells you how much of the 0/1 variation is due to genetics — and is usually much lower, especially when the trait is rare

# --- Extract variance components ---
vc     <- summary(mod.ind)$varcomp
Va     <- vc["vm(host_id, ainv)", "component"]     # Additive genetic variance
SE_Va  <- vc["vm(host_id, ainv)", "std.error"]     # Standard error of Va
Ve     <- (pi^2)/3                                        # Residual variance for logistic models

# --- Latent-scale heritability ---
h2_latent     <- Va / (Va + Ve)
dVa           <- Ve / (Va + Ve)^2                 # Derivative for delta method
SE_h2_latent  <- SE_Va * dVa

cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")

# --- Observed-scale heritability ---
p      <- mean(host_dat_clean$Champ, na.rm = TRUE)  # Trait prevalence
z      <- qnorm(p)
phi_z  <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs    <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_obs, "\n")

# --- Summary table of heritability and standard errors ---
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)


# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)


```



#NEW CHAMP BINARY MODEL
```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- host_id2

# 2. Create binary colour traits and format identifiers
host_dat <- host_dat %>%
  mutate(
    Gold   = ifelse(startsWith(Pearl_Grading_Data_Colour, "Gold"), 1, 0),
    Silver = ifelse(startsWith(Pearl_Grading_Data_Colour, "Silver"), 1, 0),
    White  = ifelse(startsWith(Pearl_Grading_Data_Colour, "White"), 1, 0),
    Cream  = ifelse(startsWith(Pearl_Grading_Data_Colour, "Cream"), 1, 0),
    Champ  = ifelse(startsWith(Pearl_Grading_Data_Colour, "Champ"), 1, 0)
  ) %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam     = host_Dam,
    Sire    = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire),
    Pearl_Harvest_Data_Days_of_Pearl_Culture = as.factor(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    Matched_Donor_Data_Nacre_lip_colour_Round = as.factor(Matched_Donor_Data_Nacre_lip_colour_Round),
    Matched_Donor_Data_Nacre_lip_colour_Flat  = as.factor(Matched_Donor_Data_Nacre_lip_colour_Flat)
  )

# 3. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(host_id)
  )

# 4. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))
ainv <- ainverse(pedind)

# 5. Fit animal model for 'Champ' colour
mod.ind <- asreml(
  fixed = Champ ~ Pearl_Harvest_Data_Days_of_Pearl_Culture +
    Matched_Donor_Data_Nacre_lip_colour_Round +
    Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 6. Update model for convergence
mod.ind <- update(mod.ind)
mod.ind <- update(mod.ind)

vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 7. Extract variance components
vc     <- summary(mod.ind)$varcomp
Va     <- vc["vm(host_id, ainv)", "component"]
SE_Va  <- vc["vm(host_id, ainv)", "std.error"]
Ve     <- (pi^2) / 3  # Logistic residual variance

# 8. Latent scale heritability
h2_latent    <- Va / (Va + Ve)
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

cat("Heritability (latent scale):       ", round(h2_latent, 4), "\n")
cat("Standard Error (latent scale):     ", round(SE_h2_latent, 4), "\n")

# 9. Observed scale heritability
p      <- mean(host_dat_clean$Champ, na.rm = TRUE)
z      <- qnorm(p)
phi_z  <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

cat("Heritability (observed scale):     ", round(h2_obs, 4), "\n")
cat("Standard Error (observed scale):   ", round(SE_obs, 4), "\n")

# 10. Summary table
herit_summary <- data.frame(
  Scale        = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error    = c(SE_h2_latent, SE_obs)
)
print(herit_summary)

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$host_id <- gsub("vm\\(host_id, ainv\\)_", "", rownames(BLUP))
head(BLUP)





```







#DONOR

#DONOR GOLD OLD

```{r}
# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data


# 2. Fix column names and convert to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ 1,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)


# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


#DONOR GOLD Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat

```{r}
# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data  # Assuming donor_data already loaded or read via read_csv()

# 2. Convert identifiers and predictors to appropriate types
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire),
    Matched_Donor_Data_Nacre_lip_colour_Round = as.factor(Matched_Donor_Data_Nacre_lip_colour_Round),
    Matched_Donor_Data_Nacre_lip_colour_Flat  = as.factor(Matched_Donor_Data_Nacre_lip_colour_Flat)
  )

# 3. Create binary trait for Gold
donor_dat <- donor_dat %>%
  mutate(
    Gold = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 4. Filter complete cases needed for modeling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat)
  )

# 5. Create pedigree
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

# 6. Generate inverse relationship matrix
ainv <- ainverse(pedind)

# 7. Fit animal model
mod.ind <- asreml(
  fixed = Gold ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 9. Calculate latent-scale heritability
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3  # Fixed residual variance for logistic models
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 10. Convert to observed scale
p      <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z      <- qnorm(p)
phi_z  <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 11. Print heritability results
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# 12. Summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)
print(herit_summary)

# 13. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Optional: calculate probability of Gold for each BLUP
BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

# 14. View BLUP output
head(BLUP)

```



# DONOR SILVER OLD

```{r}

# DONOR SILVER

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data

# 2. Fix column names and convert to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Ensure fixed effect is a factor
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(
  donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round
)

# 8. Fit the animal model
mod.ind <- asreml(
  fixed = Silver ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

print(herit_summary)

# 13. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))
actual_ids <- unique(donor_dat_clean$donor_id)
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

```


# DONOR SILVER NEW

```{r}

# DONOR SILVER

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data

# 2. Fix column names and convert to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)



# 8. Fit the animal model
mod.ind <- asreml(
  fixed = Silver ~ 1,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

print(herit_summary)

# 13. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))
actual_ids <- unique(donor_dat_clean$donor_id)
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

```




# DONOR WHITE OLD

```{r}
# DONOR WHITE

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data

# 2. Convert relevant columns to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (starting string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(White),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create pedigree
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam) %>%
  rename(ID = donor_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

# 6. Generate A-inverse matrix
ainv <- ainverse(pedind)

# 7. Ensure fixed effect is factor
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(
  donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round
)

# 8. Fit animal model
mod.ind <- asreml(
  fixed = White ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)


# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p      <- mean(donor_dat_clean$White, na.rm = TRUE)
z      <- qnorm(p)
phi_z  <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# --- Summary table ---
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)
print(herit_summary)

# 13. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))
actual_ids <- as.character(unique(donor_dat_clean$donor_id))
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# 14. Calculate probabilities
BLUP$prob_white <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)


```




# DONOR WHITE

```{r}
# DONOR WHITE

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data

# 2. Convert relevant columns to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (starting string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(White),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create pedigree
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam) %>%
  rename(ID = donor_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

# 6. Generate A-inverse matrix
ainv <- ainverse(pedind)

# 7. Ensure fixed effect is factor
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(
  donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round
)
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.factor(
  donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Flat)

# 8. Fit animal model
mod.ind <- asreml(
  fixed = White ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)


# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p      <- mean(donor_dat_clean$White, na.rm = TRUE)
z      <- qnorm(p)
phi_z  <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# --- Summary table ---
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)
print(herit_summary)

# 13. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))
actual_ids <- as.character(unique(donor_dat_clean$donor_id))
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# 14. Calculate probabilities
#BLUP$prob_white <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)


```

# DONOR CREAM OLD

```{r}

# DONOR CREAM

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data

# 2. Convert relevant columns to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 3. Ensure shell metrics are numeric
donor_dat$Matched_Donor_Data_DVH_mm <- as.numeric(donor_dat$Matched_Donor_Data_DVH_mm)
donor_dat$Matched_Donor_Data_Shell_Weight_g <- as.numeric(donor_dat$Matched_Donor_Data_Shell_Weight_g)

# 4. Create binary traits from Pearl_Grading_Data_Colour
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 5. Filter for complete cases
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Cream),
    !is.na(Matched_Donor_Data_DVH_mm),
    !is.na(Matched_Donor_Data_Shell_Weight_g),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 6. Create pedigree
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam) %>%
  rename(ID = donor_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

# 7. Generate A-inverse matrix
ainv <- ainverse(pedind)

# 8. Fit animal model
mod.ind <- asreml(
  fixed = Cream ~ Matched_Donor_Data_DVH_mm + Matched_Donor_Data_Shell_Weight_g,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

#vpredict(mod.ind, h2 ~ V1 / (V1 + 3.29))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# SE using delta method
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using Cream prevalence
p <- mean(donor_dat_clean$Cream, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# 13. Summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)
print(herit_summary)

# 14. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))
actual_ids <- as.character(unique(donor_dat_clean$donor_id))
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# 15. Calculate predicted probabilities (optional)
BLUP$prob_cream <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

```





# DONOR CREAM OLD

```{r}

# DONOR CREAM

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data  # Already loaded or imported earlier

# 2. Convert columns to appropriate types
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire),
    Matched_Donor_Data_Nacre_lip_colour_Flat  = as.factor(Matched_Donor_Data_Nacre_lip_colour_Flat),
    Matched_Donor_Data_Nacre_lip_colour_Round = as.factor(Matched_Donor_Data_Nacre_lip_colour_Round)
  )

# 3. Ensure shell metrics are numeric
donor_dat$Matched_Donor_Data_DVH_mm         <- as.numeric(donor_dat$Matched_Donor_Data_DVH_mm)
donor_dat$Matched_Donor_Data_Shell_Weight_g <- as.numeric(donor_dat$Matched_Donor_Data_Shell_Weight_g)

# 4. Create binary trait for Cream
donor_dat <- donor_dat %>%
  mutate(
    Cream = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 5. Filter for complete cases
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Cream),
    !is.na(Matched_Donor_Data_DVH_mm),
    !is.na(Matched_Donor_Data_Shell_Weight_g),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round)
  )

# 6. Create pedigree
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam) %>%
  rename(ID = donor_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

# 7. Generate A-inverse matrix
ainv <- ainverse(pedind)

# 8. Fit animal model
mod.ind <- asreml(
  fixed = Cream ~ Matched_Donor_Data_DVH_mm + Matched_Donor_Data_Shell_Weight_g +
                  Matched_Donor_Data_Nacre_lip_colour_Flat +
                  Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 9. Update model and extract variance components
mod.ind <- update.asreml(mod.ind)
vc <- summary(mod.ind)$varcomp
print(vc)

#vpredict(mod.ind, h2 ~ V1 / (V1 + 3.29))

# 10. Calculate latent-scale heritability
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2) / 3
h2_latent <- Va / (Va + Ve)

# Delta method SE
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale
p      <- mean(donor_dat_clean$Cream, na.rm = TRUE)
z      <- qnorm(p)
phi_z  <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability results
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# 13. Summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)
print(herit_summary)

# 14. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))
actual_ids <- as.character(unique(donor_dat_clean$donor_id))
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# 15. Calculate predicted probabilities
BLUP$prob_cream <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

# 16. Show result
head(BLUP)


```





# DONOR CHAMPAGNE GOOD

```{r}

# DONOR CHAMP

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data

# 2. Convert relevant columns to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam) %>%
  rename(ID = donor_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

# 6. Generate inverse relationship matrix
ainv <- ainverse(pedind)

# 7. Ensure fixed effects are factors
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round)
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Flat  <- as.factor(donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Flat)

# 8. Fit the animal model
mod.ind <- asreml(
  fixed = Champ ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)


# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))


# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using Champ prevalence
p <- mean(donor_dat_clean$Champ, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# 13. Summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)
print(herit_summary)

# 14. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))
actual_ids <- as.character(unique(donor_dat_clean$donor_id))
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# 15. Calculate predicted probabilities (optional)
BLUP$prob_champ <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

```











# 4. Quantitative Model 


use this vpredict host

```{r}

# HOST QUANTITATIVE — CLEAN VERSION (NO DISTINCT, CONVERGED TWICE, NO HERITABILITY SECTION)

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
host_dat <- hostquant %>%
  filter(!is.na(offspring_id_host) & !is.na(dam_host) & !is.na(sire_host) & !is.na(pred))

# Convert columns to appropriate types
host_dat$offspring_id_host <- as.factor(host_dat$offspring_id_host)
host_dat$dam_host <- as.factor(host_dat$dam_host)
host_dat$sire_host <- as.factor(host_dat$sire_host)

# Prepare pedigree (no distinct used)
ped <- host_dat %>%
  select(ID = offspring_id_host, SIRE = sire_host, DAM = dam_host)
ped <- data.frame(lapply(ped, as.factor))
ainv <- ainverse(ped)

# Filter complete data for modeling
host_dat_clean <- host_dat %>%
  filter(complete.cases(pred, offspring_id_host))

# Fit ASReml Gaussian animal model
mod_host <- asreml(
  fixed = pred ~ 1,
  random = ~ vm(offspring_id_host, ainv),
  residual = ~ idv(units),
  data = host_dat_clean
)

# Update twice to ensure convergence and standard errors
mod_host <- update(mod_host)
mod_host <- update(mod_host)
mod_host <- update(mod_host)
mod_host <- update(mod_host)
mod_host <- update(mod_host)

# Extract and print variance components
vc <- summary(mod_host)$varcomp
print(vc)

# Calculating heritability
vpredict(mod_host,h2~V1/(V1+V2))



# Extract BLUPs
blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
blup_host$host <- gsub("^.*\\)_", "", rownames(blup_host))
blup_host <- blup_host %>%
  filter(host %in% unique(host_dat_clean$offspring_id_host)) %>%
  mutate(EBV = solution)

# View top 10 BLUPs
head(blup_host[order(-blup_host$EBV), ], 10)

```




# DONOR QUANTITATIVE GOOD

```{r}
#WORKS
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
donor_dat <- donorquant %>%
  filter(!is.na(offspring_id_donor) & !is.na(dam_donor) & !is.na(sire_donor) & !is.na(pred))

# Convert columns to appropriate types
donor_dat$offspring_id_donor <- as.factor(donor_dat$offspring_id_donor)
donor_dat$dam_donor <- as.factor(donor_dat$dam_donor)
donor_dat$sire_donor <- as.factor(donor_dat$sire_donor)

# Prepare pedigree
ped <- donor_dat %>%
  distinct(offspring_id_donor, .keep_all = TRUE) %>%
  select(ID = offspring_id_donor, SIRE = sire_donor, DAM = dam_donor)
ped <- data.frame(lapply(ped, as.factor))
ainv <- ainverse(ped)

# Filter complete data for modelling
donor_dat_clean <- donor_dat %>%
  filter(complete.cases(pred, offspring_id_donor))

# Fit ASReml Gaussian animal model
mod_gold <- asreml(
  fixed = pred ~ 1,
  random = ~ vm(offspring_id_donor, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean
)
mod_gold <- update(mod_gold)

# Extract variance components manually
vc <- summary(mod_gold)$varcomp
print(vc)  # Print all variance components
Va <- vc["vm(offspring_id_donor, ainv)", "component"]
Ve <- vc["units!R", "component"]

# Extract BLUPs
blup_gold <- as.data.frame(summary(mod_gold, coef = TRUE)$coef.random)
blup_gold$donor <- gsub("^.*\\)_", "", rownames(blup_gold))
blup_gold <- blup_gold %>% filter(donor %in% unique(donor_dat_clean$offspring_id_donor))
blup_gold$EBV <- blup_gold$solution

# View top BLUPs
head(blup_gold[order(-blup_gold$EBV), ], 10)

vpredict(mod_gold,h2~V1/(V1+V2))

```





# 5. No. of Offspring per Donor Family




```{r}
library(readr)
library(dplyr)

# Load CSV
pedigree_host <- pedigree_host

# Create family number column safely
pedigree_host <- pedigree_host %>%
  mutate(
    family_key = paste(sire_host, dam_host, sep = "_"),
    family_number = as.integer(factor(family_key))
  )

# View the updated dataframe
View(pedigree_host)

```


```{r}
library(ggplot2)
library(dplyr)

# Create a frequency table of family_number
family_dist <- pedigree_host %>%
  count(family_number)

# Plot distribution
ggplot(family_dist, aes(x = factor(family_number), y = n)) +
  geom_bar(stat = "identity") +
  labs(
    title = "Distribution of Individuals per Family",
    x = "Family Number",
    y = "Count of Individuals"
  ) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


```{r}
ggplot(family_dist, aes(x = factor(family_number), y = n)) +
  geom_bar(stat = "identity") +
  labs(
    title = "Distribution of Individuals per Family",
    x = "Family Number",
    y = "Count of Individuals"
  ) +
  theme_minimal(base_size = 12) +
  scale_x_discrete(breaks = function(x) x[seq(1, length(x), by = 5)]) +  # Show every 5th label
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


```{r}
# Find the family with the most offspring
top_family <- family_dist %>% filter(n == max(n)) %>% pull(family_number)

ggplot(family_dist, aes(x = reorder(factor(family_number), -n), y = n, fill = family_number == top_family)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("grey70", "tomato"), guide = FALSE) +
  labs(
    title = "Host Family Size Distribution (Top Family Highlighted)",
    x = "Family Number",
    y = "Number of Offspring"
  ) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


```{r}
top_n <- 10
top_families <- family_dist %>%
  arrange(desc(n)) %>%
  slice_head(n = top_n)

ggplot(top_families, aes(x = reorder(factor(family_number), n), y = n)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = paste("Top", top_n, "Families by Offspring Count"),
    x = "Family Number",
    y = "Number of Offspring"
  ) +
  theme_minimal(base_size = 12)

```




#NEW HOST FAMILY DISTRIBUTION WITH COLOUR

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# Step 1: Create family_key and family_number
pedigree_host <- pedigree_host2 %>%
  mutate(
    family_key = paste(sire_host, dam_host, sep = "_"),
    family_number = as.integer(factor(family_key))
  )

# Step 2: Create binary colour columns (edit "Champ" to "Champagne" for consistency)
pedigree_host <- pedigree_host %>%
  mutate(
    Gold       = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver     = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White      = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream      = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champagne  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)  # renamed
  )

# Step 3: Summarise by family_number
family_summary <- pedigree_host %>%
  group_by(family_number) %>%
  summarise(
    family_size    = n(),
    Gold_count     = sum(Gold, na.rm = TRUE),
    Silver_count   = sum(Silver, na.rm = TRUE),
    White_count    = sum(White, na.rm = TRUE),
    Cream_count    = sum(Cream, na.rm = TRUE),
    Champagne_count = sum(Champagne, na.rm = TRUE)
  ) %>%
  arrange(desc(family_size))  # Optional sorting

# Step 4: Reshape to long format for ggplot
family_long <- family_summary %>%
  pivot_longer(cols = c(Gold_count, Silver_count, White_count, Cream_count, Champagne_count),
               names_to = "Colour",
               values_to = "Count") %>%
  mutate(Colour = gsub("_count", "", Colour))  # Remove "_count" suffix

# Step 5: Define custom colours
my_colours <- c(
  Gold = "#FFD700",
  Silver = "#A9A9A9",
  White = "#D3D3D3",
  Cream = "#FFFDD0",
  Champagne = "#F7E7CE"
)

# Step 6: Create stacked bar plot
ggplot(family_long, aes(x = factor(family_number), y = Count, fill = Colour)) +
  geom_bar(stat = "identity") +
  labs(
    x = "Family Number",
    y = "Pearl Count",
    title = "Distribution of Pearl Colours Across Families"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  scale_fill_manual(values = my_colours)






```



```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# Step 1: Remove NAs in sire or dam, create family_key and family_number
pedigree_host <- pedigree_host2 %>%
  filter(!is.na(sire_host) & !is.na(dam_host)) %>%
  mutate(
    family_key = paste(sire_host, dam_host, sep = "_"),
    family_number = as.integer(factor(family_key))
  )

# Step 2: Create binary colour columns
pedigree_host <- pedigree_host %>%
  mutate(
    Gold       = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver     = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White      = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream      = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champagne  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# Step 3: Summarise by family_number
family_summary <- pedigree_host %>%
  group_by(family_number) %>%
  summarise(
    family_size     = n(),
    Gold_count      = sum(Gold, na.rm = TRUE),
    Silver_count    = sum(Silver, na.rm = TRUE),
    White_count     = sum(White, na.rm = TRUE),
    Cream_count     = sum(Cream, na.rm = TRUE),
    Champagne_count = sum(Champagne, na.rm = TRUE)
  ) %>%
  arrange(desc(family_size))

# Step 4: Reshape for ggplot
family_long <- family_summary %>%
  pivot_longer(cols = c(Gold_count, Silver_count, White_count, Cream_count, Champagne_count),
               names_to = "Colour",
               values_to = "Count") %>%
  mutate(Colour = gsub("_count", "", Colour))

# Step 5: Define colours
my_colours <- c(
  Gold = "#FFD700",
  Silver = "#A9A9A9",
  White = "#D3D3D3",
  Cream = "#FFFDD0",
  Champagne = "#F7E7CE"
)

# Step 6: Plot
ggplot(family_long, aes(x = factor(family_number), y = Count, fill = Colour)) +
  geom_bar(stat = "identity") +
  labs(
    x = "Family Number",
    y = "Pearl Count",
    title = "Distribution of Pearl Colours Across Families"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  scale_fill_manual(values = my_colours)

```


#GOOD distribution of pearl colours across families host
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# Step 1: Create family_key and family_number
pedigree_host <- pedigree_host2 %>%
  mutate(
    family_key = paste(sire_host, dam_host, sep = "_"),
    family_number = as.integer(factor(family_key))
  )

# Step 2: Create binary colour columns
pedigree_host <- pedigree_host %>%
  mutate(
    Gold       = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver     = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White      = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream      = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champagne  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# Step 3: Summarise by family_number
family_summary <- pedigree_host %>%
  group_by(family_number) %>%
  summarise(
    family_size     = n(),
    Gold_count      = sum(Gold, na.rm = TRUE),
    Silver_count    = sum(Silver, na.rm = TRUE),
    White_count     = sum(White, na.rm = TRUE),
    Cream_count     = sum(Cream, na.rm = TRUE),
    Champagne_count = sum(Champagne, na.rm = TRUE)
  ) %>%
  arrange(desc(family_size))

# Step 4: Reshape and remove NA or 0 counts
family_long <- family_summary %>%
  pivot_longer(cols = c(Gold_count, Silver_count, White_count, Cream_count, Champagne_count),
               names_to = "Colour",
               values_to = "Count") %>%
  mutate(Colour = gsub("_count", "", Colour)) %>%
  filter(!is.na(Count) & Count > 0)  # Remove NA and 0s

# Step 5: Define custom colours
my_colours <- c(
  Gold = "#FFD700",
  Silver = "#A9A9A9",
  White = "#D3D3D3",
  Cream = "#FFFDD0",
  Champagne = "#F7E7CE"
)

# Step 6: Plot
ggplot(family_long, aes(x = factor(family_number), y = Count, fill = Colour)) +
  geom_bar(stat = "identity") +
  labs(
    x = "Family Number",
    y = "Pearl Count",
    title = "Distribution of Pearl Colours Across Families"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  scale_fill_manual(values = my_colours)

```

#NEW DONOR 

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# Step 1: Create family_key and family_number
pedigree_donor <- donor_data2 %>%
  mutate(
    family_key = paste(`Candidate father ID`, `Candidate mother ID`, sep = "_"),
    family_number = as.integer(factor(family_key))
  )

# Step 2: Create binary colour columns
pedigree_donor <- pedigree_donor %>%
  mutate(
    Gold       = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver     = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White      = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream      = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champagne  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# Step 3: Summarise by family_number
family_summary <- pedigree_donor %>%
  group_by(family_number) %>%
  summarise(
    family_size     = n(),
    Gold_count      = sum(Gold, na.rm = TRUE),
    Silver_count    = sum(Silver, na.rm = TRUE),
    White_count     = sum(White, na.rm = TRUE),
    Cream_count     = sum(Cream, na.rm = TRUE),
    Champagne_count = sum(Champagne, na.rm = TRUE)
  ) %>%
  arrange(desc(family_size))

# Step 4: Reshape and remove NA or 0 counts
family_long <- family_summary %>%
  pivot_longer(cols = c(Gold_count, Silver_count, White_count, Cream_count, Champagne_count),
               names_to = "Colour",
               values_to = "Count") %>%
  mutate(Colour = gsub("_count", "", Colour)) %>%
  filter(!is.na(Count) & Count > 0)  # Remove NA and 0s

# Step 5: Define custom colours
my_colours <- c(
  Gold = "#FFD700",
  Silver = "#A9A9A9",
  White = "#D3D3D3",
  Cream = "#FFFDD0",
  Champagne = "#F7E7CE"
)

# Step 6: Plot
ggplot(family_long, aes(x = factor(family_number), y = Count, fill = Colour)) +
  geom_bar(stat = "identity") +
  labs(
    x = "Family Number",
    y = "Pearl Count",
    title = "Distribution of Pearl Colours Across Families"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  scale_fill_manual(values = my_colours)
```










## DONOR




```{r}
library(readr)
library(dplyr)

# Load the data
pedigree_donor <- pedigree_donor

# Create a unique family key and assign a numeric family number
pedigree_donor <- pedigree_donor %>%
  mutate(
    family_key = paste(sire_donor, dam_donor, sep = "_"),
    family_number = as.integer(factor(family_key))
  )

# View result
View(pedigree_donor)

```

```{r}
library(ggplot2)
library(dplyr)

# Count how many times each family_number appears (offspring per family)
family_dist <- pedigree_donor %>%
  count(family_number)

# Plot
ggplot(family_dist, aes(x = reorder(factor(family_number), -n), y = n)) +
  geom_col(fill = "skyblue") +
  labs(
    title = "Number of Offspring per Donor Family",
    x = "Family Number",
    y = "Offspring Count"
  ) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

```


```{r}
top10 <- family_dist %>% arrange(desc(n)) %>% slice_head(n = 10)
ggplot(top10, aes(x = reorder(factor(family_number), n), y = n)) +
  geom_col(fill = "tomato") +
  coord_flip() +
  labs(title = "Top 10 Donor Families by Offspring Count",
       x = "Family Number", y = "Offspring Count") +
  theme_minimal()

```


```{r}
library(ggplot2)
library(dplyr)

# Count number of offspring per family_number
family_counts <- pedigree_donor %>%
  count(family_number, name = "n_offspring")

# Plot: Number of offspring per family
ggplot(family_counts, aes(x = factor(family_number), y = n_offspring)) +
  geom_bar(stat = "identity", fill = "black") +
  labs(
    title = "Number of Offspring per Full-Sib Family",
    x = "Family Number",
    y = "Number of Offspring"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
  )

```




# 6. EBVs vs Observed Proportion of Gold Pearls




```{r}
# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(donor_dat$Matched_Donor_Data_Nacre_lip_colour_Round)
donor_dat$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.factor(donor_dat$Matched_Donor_Data_Nacre_lip_colour_Flat)


# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```

```{r}
# Load required library
library(ggplot2)

# --- Step 1: Rename EBV column and ensure donor_id is a factor ---
BLUP <- BLUP %>%
  rename(EBV = solution) %>%
  mutate(donor_id = as.factor(donor_id))


# --- Step 2: Calculate observed proportion of Gold pearls per donor ---
obs_gold <- donor_dat_clean %>%
  group_by(donor_id) %>%
  summarise(
    prop_gold = mean(Gold, na.rm = TRUE)
  ) %>%
  ungroup()

# --- Step 3: Merge EBVs with observed gold proportion ---
plot_df <- BLUP %>%
  inner_join(obs_gold, by = "donor_id") %>%
  filter(!is.na(EBV), !is.na(prop_gold))

# --- Step 4: Exponential model fit ---
plot_df <- plot_df %>%
  mutate(prop_gold_adj = pmax(prop_gold, 1e-6))  # avoid log(0)

# Starting values from log-linear regression
start_vals <- coef(lm(log(prop_gold_adj) ~ EBV, data = plot_df))
start_a <- exp(start_vals[1])
start_b <- start_vals[2]

# Fit exponential model: y = a * exp(b * x)
exp_model <- nls(prop_gold_adj ~ a * exp(b * EBV),
                 data = plot_df,
                 start = list(a = start_a, b = start_b),
                 control = list(maxiter = 200, warnOnly = TRUE))

# --- Step 5: Generate fitted curve ---
curve_df <- data.frame(EBV = seq(min(plot_df$EBV), max(plot_df$EBV), length.out = 200))
curve_df$pred <- predict(exp_model, newdata = curve_df)

# --- Step 6: Plot without point size ---
ggplot(plot_df, aes(x = EBV, y = prop_gold)) +
  geom_point(color = "darkgoldenrod", alpha = 0.8) +
  geom_line(data = curve_df, aes(x = EBV, y = pred), color = "black", linewidth = 1) +
  scale_y_continuous(limits = c(0, 1), expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    x = "Estimated Breeding Value (EBV) for Gold",
    y = "Observed Proportion of Gold Pearls",
    title = "Donor EBV vs Observed Gold Proportion",
    subtitle = "Fitted with exponential model: y = a · exp(b · EBV)"
  ) +
  theme_minimal(base_size = 13)

# Optional: print model coefficients
cat("Fitted exponential model:\n")
print(coef(exp_model))

cor(plot_df$EBV, plot_df$prop_gold, method = "pearson", use = "complete.obs")

cor.test(plot_df$EBV, plot_df$prop_gold, method = "pearson")



```





```{r}
# Calculate observed gold proportion
obs_gold <- donor_dat_clean %>%
  group_by(donor_id) %>%
  summarise(
    n = n(),
    prop_gold = mean(Gold, na.rm = TRUE)
  )

# Prepare BLUP table
BLUP$donor_id <- as.factor(BLUP$donor_id)
merged <- left_join(obs_gold, BLUP, by = "donor_id")

lm_ebv_gold <- lm(prop_gold ~ solution, data = merged)
summary(lm_ebv_gold)

library(ggplot2)

ggplot(merged, aes(x = solution, y = prop_gold)) +
  geom_point(color = "black") +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(
    x = "Estimated Breeding Value (EBV)",
    y = "Observed Proportion of Gold Pearls",
    title = "Linear Relationship between EBV and Observed Gold Proportion"
  ) +
  theme_minimal()

# Calculate Pearson correlation
cor_test <- cor.test(merged$solution, merged$prop_gold, method = "pearson")

# Print results
print(cor_test)



```



#no fixed effects can't use this exponential 
```{r}

# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )




# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ 1,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

# Load required library
library(ggplot2)

# --- Step 1: Rename EBV column and ensure donor_id is a factor ---
BLUP <- BLUP %>%
  rename(EBV = solution) %>%
  mutate(donor_id = as.factor(donor_id))


# --- Step 2: Calculate observed proportion of Gold pearls per donor ---
obs_gold <- donor_dat_clean %>%
  group_by(donor_id) %>%
  summarise(
    prop_gold = mean(Gold, na.rm = TRUE)
  ) %>%
  ungroup()

# --- Step 3: Merge EBVs with observed gold proportion ---
plot_df <- BLUP %>%
  inner_join(obs_gold, by = "donor_id") %>%
  filter(!is.na(EBV), !is.na(prop_gold))

# --- Step 4: Exponential model fit ---
plot_df <- plot_df %>%
  mutate(prop_gold_adj = pmax(prop_gold, 1e-6))  # avoid log(0)

# Starting values from log-linear regression
start_vals <- coef(lm(log(prop_gold_adj) ~ EBV, data = plot_df))
start_a <- exp(start_vals[1])
start_b <- start_vals[2]

# Fit exponential model: y = a * exp(b * x)
exp_model <- nls(prop_gold_adj ~ a * exp(b * EBV),
                 data = plot_df,
                 start = list(a = start_a, b = start_b),
                 control = list(maxiter = 200, warnOnly = TRUE))

# --- Step 5: Generate fitted curve ---
curve_df <- data.frame(EBV = seq(min(plot_df$EBV), max(plot_df$EBV), length.out = 200))
curve_df$pred <- predict(exp_model, newdata = curve_df)

# --- Step 6: Plot without point size ---
ggplot(plot_df, aes(x = EBV, y = prop_gold)) +
  geom_point(color = "darkgoldenrod", alpha = 0.8) +
  geom_line(data = curve_df, aes(x = EBV, y = pred), color = "black", linewidth = 1) +
  scale_y_continuous(limits = c(0, 1), expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    x = "Estimated Breeding Value (EBV) for Gold",
    y = "Observed Proportion of Gold Pearls",
    title = "Donor EBV vs Observed Gold Proportion",
    subtitle = "Fitted with exponential model: y = a · exp(b · EBV)"
  ) +
  theme_minimal(base_size = 13)

# Optional: print model coefficients
cat("Fitted exponential model:\n")
print(coef(exp_model))

cor(plot_df$EBV, plot_df$prop_gold, method = "pearson", use = "complete.obs")

cor.test(plot_df$EBV, plot_df$prop_gold, method = "pearson")



```


#can't use this no fixed effects linear regression 

```{r}

# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )




# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ 1,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)
# quantitative model no fixed effects

# Calculate observed gold proportion
obs_gold <- donor_dat_clean %>%
  group_by(donor_id) %>%
  summarise(
    n = n(),
    prop_gold = mean(Gold, na.rm = TRUE)
  )

# Prepare BLUP table
BLUP$donor_id <- as.factor(BLUP$donor_id)
merged <- left_join(obs_gold, BLUP, by = "donor_id")

lm_ebv_gold <- lm(prop_gold ~ solution, data = merged)
summary(lm_ebv_gold)

library(ggplot2)

ggplot(merged, aes(x = solution, y = prop_gold)) +
  geom_point(color = "black") +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(
    x = "Estimated Breeding Value (EBV)",
    y = "Observed Proportion of Gold Pearls",
    title = "Linear Relationship between EBV and Observed Gold Proportion"
  ) +
  theme_minimal()

# Calculate Pearson correlation
cor_test <- cor.test(merged$solution, merged$prop_gold, method = "pearson")

# Print results
print(cor_test)



```




```{r}

#WORKS
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
donor_dat <- donorquant %>%
  filter(!is.na(offspring_id_donor) & !is.na(dam_donor) & !is.na(sire_donor) & !is.na(pred))

# Convert columns to appropriate types
donor_dat$offspring_id_donor <- as.factor(donor_dat$offspring_id_donor)
donor_dat$dam_donor <- as.factor(donor_dat$dam_donor)
donor_dat$sire_donor <- as.factor(donor_dat$sire_donor)

# Prepare pedigree
ped <- donor_dat %>%
  distinct(offspring_id_donor, .keep_all = TRUE) %>%
  select(ID = offspring_id_donor, SIRE = sire_donor, DAM = dam_donor)
ped <- data.frame(lapply(ped, as.factor))
ainv <- ainverse(ped)

# Filter complete data for modelling
donor_dat_clean <- donor_dat %>%
  filter(complete.cases(pred, offspring_id_donor))


# Calculate average "goldness" (pred) for each donor
mean_goldness <- donor_dat %>%
  filter(!is.na(pred), !is.na(offspring_id_donor)) %>%
  group_by(offspring_id_donor) %>%
  summarise(mean_gold = mean(pred, na.rm = TRUE),
            n_pearls = n()) %>%
  ungroup()

# OPTIONAL: View summary
print(head(mean_goldness))

# Fit ASReml Gaussian animal model
mod_gold <- asreml(
  fixed = pred ~ 1,
  random = ~ vm(offspring_id_donor, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean
)
mod_gold <- update(mod_gold)

# Extract variance components manually
vc <- summary(mod_gold)$varcomp
print(vc)  # Print all variance components
Va <- vc["vm(offspring_id_donor, ainv)", "component"]
Ve <- vc["units!R", "component"]

# Extract BLUPs
blup_gold <- as.data.frame(summary(mod_gold, coef = TRUE)$coef.random)
blup_gold$donor <- gsub("^.*\\)_", "", rownames(blup_gold))
blup_gold <- blup_gold %>% filter(donor %in% unique(donor_dat_clean$offspring_id_donor))
blup_gold$EBV <- blup_gold$solution

# View top BLUPs
head(blup_gold[order(-blup_gold$EBV), ], 10)

vpredict(mod_gold,h2~V1/(V1+V2))


# Merge mean_gold with BLUPs (EBVs)
merged_df <- left_join(mean_goldness, blup_gold, by = c("offspring_id_donor" = "donor"))


# View merged table
print(merged_df)

# Merge EBV and mean_goldness
merged_df <- blup_gold %>%
  select(donor, EBV) %>%
  inner_join(mean_goldness, by = c("donor" = "offspring_id_donor"))

# Check merged result
head(merged_df)

# Load ggplot2 
library(ggplot2)

# Scatter plot + linear regression line
ggplot(merged_df, aes(x = EBV, y = mean_gold)) +
  geom_point(aes(color = "Observed Data")) +
  geom_smooth(method = "lm", se = FALSE, aes(color = "Linear Fit")) +
  scale_color_manual(values = c("Observed Data" = "black", "Linear Fit" = "blue")) +
  labs(
    x = "Estimated Breeding Value (EBV)",
    y = "Mean Predicted Colour (Goldness)",
    title = "Donor EBV vs Mean Goldness",
    color = "Legend"
  ) +
  theme_minimal()

# Pearson correlation
cor_test_result <- cor.test(merged_df$EBV, merged_df$mean_gold, method = "pearson")
print(cor_test_result)
```




```{r}

#WORKS
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
donor_dat <- donorquant %>%
  filter(!is.na(offspring_id_donor) & !is.na(dam_donor) & !is.na(sire_donor) & !is.na(pred) & !is.na(Matched_Donor_Data_Nacre_lip_colour_Round) & !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat))

# Convert columns to appropriate types
donor_dat$offspring_id_donor <- as.factor(donor_dat$offspring_id_donor)
donor_dat$dam_donor <- as.factor(donor_dat$dam_donor)
donor_dat$sire_donor <- as.factor(donor_dat$sire_donor)
donor_dat$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(donor_dat$Matched_Donor_Data_Nacre_lip_colour_Round)
donor_dat$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.factor(donor_dat$Matched_Donor_Data_Nacre_lip_colour_Flat)

# Prepare pedigree
ped <- donor_dat %>%
  distinct(offspring_id_donor, .keep_all = TRUE) %>%
  select(ID = offspring_id_donor, SIRE = sire_donor, DAM = dam_donor)
ped <- data.frame(lapply(ped, as.factor))
ainv <- ainverse(ped)

# Filter complete data for modelling
donor_dat_clean <- donor_dat %>%
  filter(complete.cases(pred, offspring_id_donor))


# Calculate average "goldness" (pred) for each donor
mean_goldness <- donor_dat %>%
  filter(!is.na(pred), !is.na(offspring_id_donor)) %>%
  group_by(offspring_id_donor) %>%
  summarise(mean_gold = mean(pred, na.rm = TRUE),
            n_pearls = n()) %>%
  ungroup()

# OPTIONAL: View summary
print(head(mean_goldness))

# Fit ASReml Gaussian animal model
mod_gold <- asreml(
  fixed = pred ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(offspring_id_donor, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean
)
mod_gold <- update(mod_gold)

# Extract variance components manually
vc <- summary(mod_gold)$varcomp
print(vc)  # Print all variance components
Va <- vc["vm(offspring_id_donor, ainv)", "component"]
Ve <- vc["units!R", "component"]

# Extract BLUPs
blup_gold <- as.data.frame(summary(mod_gold, coef = TRUE)$coef.random)
blup_gold$donor <- gsub("^.*\\)_", "", rownames(blup_gold))
blup_gold <- blup_gold %>% filter(donor %in% unique(donor_dat_clean$offspring_id_donor))
blup_gold$EBV <- blup_gold$solution

# View top BLUPs
head(blup_gold[order(-blup_gold$EBV), ], 10)

vpredict(mod_gold,h2~V1/(V1+V2))


# Merge mean_gold with BLUPs (EBVs)
merged_df <- left_join(mean_goldness, blup_gold, by = c("offspring_id_donor" = "donor"))


# View merged table
print(merged_df)

# Merge EBV and mean_goldness
merged_df <- blup_gold %>%
  select(donor, EBV) %>%
  inner_join(mean_goldness, by = c("donor" = "offspring_id_donor"))

# Check merged result
head(merged_df)

# Load ggplot2 
library(ggplot2)

# Scatter plot + linear regression line
ggplot(merged_df, aes(x = EBV, y = mean_gold)) +
  geom_point(aes(color = "Observed Data")) +
  geom_smooth(method = "lm", se = FALSE, aes(color = "Linear Fit")) +
  scale_color_manual(values = c("Observed Data" = "black", "Linear Fit" = "blue")) +
  labs(
    x = "Estimated Breeding Value (EBV)",
    y = "Mean Predicted Colour (Goldness)",
    title = "Donor EBV vs Mean Goldness",
    color = "Legend"
  ) +
  theme_minimal()

# Pearson correlation
cor_test_result <- cor.test(merged_df$EBV, merged_df$mean_gold, method = "pearson")
print(cor_test_result)

```









# 7. Confusion Matrix (~500 pearls)


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
donor_dat <- donorquant %>%
  filter(!is.na(offspring_id_donor) & 
         !is.na(dam_donor) & 
         !is.na(sire_donor) & 
         !is.na(pred))

# Convert columns to appropriate types
donor_dat <- donor_dat %>%
  mutate(
    offspring_id_donor = as.factor(offspring_id_donor),
    dam_donor = as.factor(dam_donor),
    sire_donor = as.factor(sire_donor),
    Matched_Donor_Data_Nacre_lip_colour_Round = as.factor(Matched_Donor_Data_Nacre_lip_colour_Round),
    Matched_Donor_Data_Nacre_lip_colour_Flat  = as.factor(Matched_Donor_Data_Nacre_lip_colour_Flat)
  )

# Drop unused factor levels
donor_dat <- droplevels(donor_dat)

# Filter complete cases including new fixed effects
donor_dat_clean <- donor_dat %>%
  filter(complete.cases(
    pred,
    offspring_id_donor,
    Matched_Donor_Data_Nacre_lip_colour_Round,
    Matched_Donor_Data_Nacre_lip_colour_Flat
  ))

# Add units column (required by ASReml)
donor_dat_clean$units <- 1:nrow(donor_dat_clean)

# Prepare pedigree
ped <- donor_dat_clean %>%
  distinct(offspring_id_donor, .keep_all = TRUE) %>%
  select(ID = offspring_id_donor, SIRE = sire_donor, DAM = dam_donor)
ped <- data.frame(lapply(ped, as.factor))
ainv <- ainverse(ped)

# Fit ASReml Gaussian animal model with the two fixed effects
mod_gold <- asreml(
  fixed = pred ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(offspring_id_donor, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean
)
mod_gold <- update(mod_gold)

# Extract variance components
vc <- summary(mod_gold)$varcomp
print(vc)
Va <- vc["vm(offspring_id_donor, ainv)", "component"]
Ve <- vc["units!R", "component"]

# Calculate heritability
vpredict(mod_gold, h2 ~ V1 / (V1 + V2))

# Extract BLUPs
blup_gold <- as.data.frame(summary(mod_gold, coef = TRUE)$coef.random)
blup_gold$donor <- gsub("^.*\\)_", "", rownames(blup_gold))
blup_gold <- blup_gold %>%
  filter(donor %in% unique(donor_dat_clean$offspring_id_donor)) %>%
  rename(EBV = solution)

# View top BLUPs
head(blup_gold[order(-blup_gold$EBV), ], 10)

```



Comparing EBV values to True Gold Values
```{r}
blup_gold$donor = as.numeric(blup_gold$donor)
pearl_df = read_csv("C:/Users/User2/Documents/pearl_project/PearlOperationalData.csv")
p_df = pearl_df %>% select(c("First_Op_Data_Saibo_No", "Pearl_Grading_Data_Unique_Code", "Pearl_Grading_Data_Colour"))
```

```{r}
p_df = p_df %>% 
  rename(donor = "First_Op_Data_Saibo_No", true_colour = "Pearl_Grading_Data_Colour", pearl_id = "Pearl_Grading_Data_Unique_Code")
p_df$donor = as.numeric(p_df$donor)
```

```{r}
pred_df = left_join(p_df, blup_gold, by="donor")
```

```{r}
pred_df = na.omit(pred_df)
```

```{r}
pred_df$pred_colour = ifelse(pred_df$EBV > 0.04143747, "Gold", "Other")
pred_df$true_colour = ifelse(grepl("^Gold", pred_df$true_colour), "Gold", "Other")
table(pred_df$true_colour, pred_df$pred_colour)

```


```{r}
#might be wrong
# Load ROC library
library(pROC)

# Convert true_colour into binary (1 = Gold, 0 = Other)
pred_df$true_binary <- ifelse(pred_df$true_colour == "Gold", 1, 0)

# ROC analysis using EBVs as predictors
roc_obj <- roc(pred_df$true_binary, pred_df$EBV)

# Plot ROC curve
plot(roc_obj, col="blue", main="ROC Curve - Donor Quantitative Model")

# Get optimal threshold using Youden's Index
youden <- coords(roc_obj, "best", best.method="youden",
                 ret=c("threshold", "sensitivity", "specificity", "accuracy"))

print(youden)

```





## AUC NEW 


```{r}
# Create a binary trait for 'Gold' classification
donor_dat_clean <- donor_dat_clean %>%
  mutate(Gold = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0))


library(pROC)

# Compute AUC
roc_gold <- roc(donor_dat_clean$Gold, donor_dat_clean$pred)
auc(roc_gold)

plot(roc_gold, main = "ROC Curve for Quantitative Model (Gold Colour)")


```




#try new good donorquant4 !!!


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
donor_dat <- donorquant4 %>%
  filter(!is.na(donor_offspring_id) & 
         !is.na(donor_dam) & 
         !is.na(donor_sire) & 
         !is.na(pred))

# Convert columns to appropriate types
donor_dat <- donor_dat %>%
  mutate(
    donor_offspring_id = as.factor(donor_offspring_id),
    donor_dam = as.factor(donor_dam),
    donor_sire = as.factor(donor_sire),
    Matched_Donor_Data_Nacre_lip_colour_Round = as.factor(Matched_Donor_Data_Nacre_lip_colour_Round),
    Matched_Donor_Data_Nacre_lip_colour_Flat  = as.factor(Matched_Donor_Data_Nacre_lip_colour_Flat)
  )

# Drop unused factor levels
donor_dat <- droplevels(donor_dat)

# Filter complete cases including new fixed effects
donor_dat_clean <- donor_dat %>%
  filter(complete.cases(
    pred,
    donor_offspring_id,
    Matched_Donor_Data_Nacre_lip_colour_Round,
    Matched_Donor_Data_Nacre_lip_colour_Flat
  ))

# Add units column (required by ASReml)
donor_dat_clean$units <- 1:nrow(donor_dat_clean)

# Prepare pedigree
ped <- donor_dat_clean %>%
  distinct(donor_offspring_id, .keep_all = TRUE) %>%
  select(ID = donor_offspring_id, SIRE = donor_sire, DAM = donor_dam)
ped <- data.frame(lapply(ped, as.factor))
ainv <- ainverse(ped)

# Fit ASReml Gaussian animal model with the two fixed effects
mod_gold <- asreml(
  fixed = pred ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_offspring_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean
)
mod_gold <- update(mod_gold)

# Extract variance components
vc <- summary(mod_gold)$varcomp
print(vc)
Va <- vc["vm(offspring_id_donor, ainv)", "component"]
Ve <- vc["units!R", "component"]

# Calculate heritability
vpredict(mod_gold, h2 ~ V1 / (V1 + V2))

# Extract BLUPs
blup_gold <- as.data.frame(summary(mod_gold, coef = TRUE)$coef.random)
blup_gold$donor <- gsub("^.*\\)_", "", rownames(blup_gold))
blup_gold <- blup_gold %>%
  filter(donor %in% unique(donor_dat_clean$donor_offspring_id)) %>%
  rename(EBV = solution)

# View top BLUPs
head(blup_gold[order(-blup_gold$EBV), ], 10)

```


```{r}

# --- AUC for quantitative predictor 'pred' vs Gold/non-Gold ---

# 1) Ensure a binary outcome exists (Gold = 1, else 0)
if ("Pearl_Grading_Data_Colour" %in% names(donor_dat_clean)) {
  donor_dat_clean <- donor_dat_clean %>%
    mutate(Gold = as.integer(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE)))
} else if (!"Gold" %in% names(donor_dat_clean)) {
  stop("No 'Gold' label found. Add a binary column 'Gold' (1=gold, 0=non-gold) or provide 'Pearl_Grading_Data_Colour'.")
}

# 2) Install/load pROC if needed
if (!requireNamespace("pROC", quietly = TRUE)) install.packages("pROC")
library(pROC)

# 3) Build ROC using the quantitative score 'pred' as the predictor
#    (Positive class is 1 = Gold)
roc_gold <- roc(response = donor_dat_clean$Gold,
                predictor = donor_dat_clean$pred,
                quiet = TRUE, direction = ">")

# 4) AUC and 95% CI
auc_val <- auc(roc_gold)
auc_ci  <- ci.auc(roc_gold)

cat("AUC:", as.numeric(auc_val), "\n")
cat("95% CI:", paste(round(auc_ci[1], 4), "to", round(auc_ci[3], 4)), "\n")

# 5) Optimal threshold via Youden's J (sensitivity + specificity - 1)
best <- coords(roc_gold, "best",
               best.method = "youden",
               ret = c("threshold", "sensitivity", "specificity", "youden"))
print(best)

# 6) (Optional) Plot ROC
plot(roc_gold, main = "ROC: Quantitative predictor (pred) for Gold vs non-Gold")

# 7) (Optional) neatly capture a summary table
auc_summary <- data.frame(
  Model = "Quantitative (pred)",
  AUC = as.numeric(auc_val),
  CI_lower = as.numeric(auc_ci[1]),
  CI_upper = as.numeric(auc_ci[3]),
  Threshold = best["threshold"],
  Sensitivity = best["sensitivity"],
  Specificity = best["specificity"],
  Youden_Index = best["youden"]
)
print(auc_summary)


```

# new use this AUC DONOR QUANT
```{r}
# Load libraries
library(readr)
library(dplyr)
library(pROC)

# Load the data (use the path where your CSV is located)
donor_dat <- read_csv("donorquant4.csv")

# Clean data: keep complete cases
donor_dat_clean <- donor_dat %>%
  filter(!is.na(pred), !is.na(Colour))

# Create binary trait: Gold = 1, else = 0
donor_dat_clean <- donor_dat_clean %>%
  mutate(Gold = ifelse(grepl("^Gold", Colour, ignore.case = TRUE), 1, 0))

# Calculate ROC and AUC
roc_gold <- roc(donor_dat_clean$Gold, donor_dat_clean$pred)
print(roc_gold)
auc(roc_gold)

# Optional: Plot ROC curve
plot(roc_gold, main = "ROC Curve for Gold vs Non-Gold (Quantitative Model)")


```














```{r}
library(ggplot2)

ggplot(pred_df, aes(x = EBV, fill = true_colour)) +
  geom_density(alpha = 0.6) +
  scale_fill_manual(values = c("Gold" = "goldenrod", "Other" = "grey70")) +
  labs(
    title = "Distribution of EBV by True Pearl Colour",
    x = "Estimated Breeding Value (EBV)",
    y = "Density",
    fill = "True Colour"
  ) +
  theme_minimal()


ggplot(pred_df, aes(x = EBV, fill = true_colour)) +
  geom_histogram(alpha = 0.6, position = "identity", bins = 30, color = "black") +
  scale_fill_manual(values = c("Gold" = "goldenrod", "Other" = "grey70")) +
  labs(
    title = "Histogram of EBV by True Colour",
    x = "Estimated Breeding Value (EBV)",
    y = "Count",
    fill = "True Colour"
  ) +
  theme_minimal()

ggplot(pred_df, aes(x = true_colour, y = EBV, fill = true_colour)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.3) +
  scale_fill_manual(values = c("Gold" = "goldenrod", "Other" = "grey70")) +
  labs(
    title = "Boxplot of EBV by True Colour",
    x = "True Colour",
    y = "Estimated Breeding Value (EBV)"
  ) +
  theme_minimal()


```


# BINARY MODEL GOLD 
# TESTING THE SAME FIXED EFFECTS IN THE MODEL 

#DONOR 
GOLD BINARY MODEL #with fixed effects

```{r}
# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(donor_dat$Matched_Donor_Data_Nacre_lip_colour_Round)
donor_dat$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.factor(donor_dat$Matched_Donor_Data_Nacre_lip_colour_Flat)


# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```

```{r}
# Load AUC calculation library
library(pROC)

# Ensure BLUP$donor_id and donor_dat_clean$donor_id are both characters for merging
BLUP$donor_id <- as.character(BLUP$donor_id)
donor_dat_clean$donor_id <- as.character(donor_dat_clean$donor_id)

# Merge BLUPs with donor data to get true labels
merged_auc <- merge(BLUP, donor_dat_clean[, c("donor_id", "Gold")], by = "donor_id")

# Remove duplicates if necessary
merged_auc <- merged_auc[!duplicated(merged_auc$donor_id), ]

# Calculate ROC and AUC
roc_blup <- roc(response = merged_auc$Gold, predictor = merged_auc$solution)
auc_value <- auc(roc_blup)

# Print results
print(roc_blup)
cat("AUC for binary model (BLUPs as predictor):", auc_value, "\n")

# Optional: Plot ROC curve
plot(roc_blup, main = "ROC Curve: Binary Model (BLUPs for Gold Classification)")

```



#0.216018437

```{r}
# Load pearl grading data
binary_pearl_df <- read_csv("C:/Users/User2/Documents/pearl_project/PearlOperationalData.csv")

# Select relevant columns
b_p_df <- binary_pearl_df %>%
  select(First_Op_Data_Saibo_No, Pearl_Grading_Data_Unique_Code, Pearl_Grading_Data_Colour) %>%
  rename(
    donor = First_Op_Data_Saibo_No,
    pearl_id = Pearl_Grading_Data_Unique_Code,
    true_colour = Pearl_Grading_Data_Colour
  )

# Ensure donor IDs are numeric for join
b_p_df$donor <- as.numeric(b_p_df$donor)
BLUP$donor_id <- as.numeric(BLUP$donor_id)

# Rename for clarity before joining
colnames(BLUP)[colnames(BLUP) == "donor_id"] <- "donor"

# Join EBV data with phenotype data
b_pred_df <- left_join(b_p_df, BLUP, by = "donor")

# Remove incomplete cases
b_pred_df <- na.omit(b_pred_df)

# Classify predicted colour based on EBV threshold
b_pred_df$pred_colour <- ifelse(b_pred_df$solution > 0.3388436, "Gold", "Other")

# Standardize true colour classification
b_pred_df$true_colour <- ifelse(grepl("^Gold", b_pred_df$true_colour, ignore.case = TRUE), "Gold", "Other")

# Generate confusion matrix
conf_mat <- table(True = b_pred_df$true_colour, Predicted = b_pred_df$pred_colour)
print(conf_mat)

#conf_mat <- table(True = b_pred_df$pred_colour, Predicted = b_pred_df$true_colour)
#print(conf_mat)
```

```{r}

#pred_colour 

library(ggplot2)

ggplot(b_pred_df, aes(x = solution, fill = true_colour)) +
  geom_density(alpha = 0.6) +
  scale_fill_manual(values = c("Gold" = "goldenrod", "Other" = "grey70")) +
  labs(
    title = "Density Plot of Donor EBVs by True Pearl Colour (Binary Model)",
    x = "Estimated Breeding Value (EBV)",
    y = "Density",
    fill = "True Colour"
  ) +
  theme_minimal()

```


```{r}
ggplot(b_pred_df, aes(x = solution, fill = true_colour)) +
  geom_histogram(alpha = 0.6, position = "identity", bins = 30, color = "black") +
  scale_fill_manual(values = c("Gold" = "goldenrod", "Other" = "grey70")) +
  labs(
    title = "Histogram of Donor EBVs by True Pearl Colour (Binary Model)",
    x = "Estimated Breeding Value (EBV)",
    y = "Count",
    fill = "True Colour"
  ) +
  theme_minimal()

```


```{r}
ggplot(b_pred_df, aes(x = true_colour, y = solution, fill = true_colour)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.15, alpha = 0.4) +
  scale_fill_manual(values = c("Gold" = "goldenrod", "Other" = "grey70")) +
  labs(
    title = "Boxplot of EBVs by True Pearl Colour (Binary Model)",
    x = "True Colour",
    y = "Estimated Breeding Value (EBV)"
  ) +
  theme_minimal()

```

```{r}

#ignore this 
# Load pROC for ROC analysis
library(pROC)

# Create binary (0/1) outcome for ROC
b_pred_df$true_binary <- ifelse(b_pred_df$true_colour == "Gold", 1, 0)

# Generate ROC curve using EBVs (solution column)
roc_obj <- roc(b_pred_df$true_binary, b_pred_df$solution)

# Find optimal threshold with Youden's Index
youden <- coords(roc_obj, x = "best", best.method = "youden", ret = c("threshold", "sensitivity", "specificity", "accuracy"))
print(youden)

# Optional: plot ROC curve
plot(roc_obj, col = "blue", lwd = 2, main = "ROC Curve for Binary Gold Model")
abline(a = 0, b = 1, lty = 2, col = "gray")

```

```{r}
test_df = b_pred_df

f1_scores = c()
accuracies = c()
misclasses = c()
thresholds = seq(min(b_pred_df$solution), max(b_pred_df$solution), length.out=1000)
i=1

for (threshold in thresholds) {
  test_df$pred_colour <- ifelse(test_df$solution > threshold, "Gold", "Other")
  test_cm = table(Pred = test_df$pred_colour, True = test_df$true_colour)
  # f1 = ifelse(dim(test_cm)==c(2,2), 2*test_cm[1,1]/(2*test_cm[1,1]+test_cm[1,2]+test_cm[2,1]), 0)
  # f1_scores[i] = f1
  # accuracy = ifelse(dim(test_cm)==c(2,2), sum(diag(test_cm))/sum(test_cm), 0)
  # accuracies[i] = accuracy
  misclass = ifelse(dim(test_cm)==c(2,2) & test_cm[2,1]==0, test_cm[1,2]+test_cm[2,1], NA)
  misclasses[i] = misclass
  i=i+1
}

results = cbind(thresholds, f1_scores, accuracies, misclasses)
```


#21 aug



```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
donor_dat <- donorquant4 %>%
  filter(!is.na(donor_offspring_id) & 
         !is.na(donor_dam) & 
         !is.na(donor_sire) & 
         !is.na(pred))

# Convert columns to appropriate types
donor_dat <- donor_dat %>%
  mutate(
    donor_offspring_id = as.factor(donor_offspring_id),
    donor_dam = as.factor(donor_dam),
    donor_sire = as.factor(donor_sire),
    Matched_Donor_Data_Nacre_lip_colour_Round = as.factor(Matched_Donor_Data_Nacre_lip_colour_Round),
    Matched_Donor_Data_Nacre_lip_colour_Flat  = as.factor(Matched_Donor_Data_Nacre_lip_colour_Flat)
  )

# Drop unused factor levels
donor_dat <- droplevels(donor_dat)

# Filter complete cases including new fixed effects
donor_dat_clean <- donor_dat %>%
  filter(complete.cases(
    pred,
    donor_offspring_id,
    Matched_Donor_Data_Nacre_lip_colour_Round,
    Matched_Donor_Data_Nacre_lip_colour_Flat
  ))

# Add units column (required by ASReml)
donor_dat_clean$units <- 1:nrow(donor_dat_clean)

# Prepare pedigree
ped <- donor_dat_clean %>%
  distinct(donor_offspring_id, .keep_all = TRUE) %>%
  select(ID = donor_offspring_id, SIRE = donor_sire, DAM = donor_dam)
ped <- data.frame(lapply(ped, as.factor))
ainv <- ainverse(ped)

# Fit ASReml Gaussian animal model with the two fixed effects
mod_gold <- asreml(
  fixed = pred ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_offspring_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean
)
mod_gold <- update(mod_gold)

# Extract variance components
vc <- summary(mod_gold)$varcomp
print(vc)
Va <- vc["vm(offspring_id_donor, ainv)", "component"]
Ve <- vc["units!R", "component"]

# Calculate heritability
vpredict(mod_gold, h2 ~ V1 / (V1 + V2))

# Extract BLUPs
blup_gold <- as.data.frame(summary(mod_gold, coef = TRUE)$coef.random)
blup_gold$donor <- gsub("^.*\\)_", "", rownames(blup_gold))
blup_gold <- blup_gold %>%
  filter(donor %in% unique(donor_dat_clean$donor_offspring_id)) %>%
  rename(EBV = solution)

# View top BLUPs
head(blup_gold[order(-blup_gold$EBV), ], 10)

```



#DONOR 
GOLD BINARY MODEL #with fixed effects

```{r}
# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(donor_dat$Matched_Donor_Data_Nacre_lip_colour_Round)
donor_dat$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.factor(donor_dat$Matched_Donor_Data_Nacre_lip_colour_Flat)


# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```

```{r}
quant_blups <- blup_gold %>%
  select(donor_id = donor, pred = EBV)

# Merge gold trait
quant_gold <- donor_dat_clean %>%
  mutate(Gold = ifelse(grepl("^Gold", Colour, ignore.case = TRUE), 1, 0)) %>%
  select(donor_offspring_id, Gold) %>%
  distinct()

quant_model_data <- inner_join(quant_blups, quant_gold, by = c("donor_id" = "donor_offspring_id"))

```



```{r}
bin_blups <- BLUP %>%
  select(donor_id, solution)

# Get binary gold classification
bin_gold <- donor_dat_clean %>%
  mutate(Gold = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)) %>%
  select(donor_id, Gold) %>%
  distinct()

bin_model_data <- inner_join(bin_blups, bin_gold, by = "donor_id")

```



```{r}
merged_auc <- inner_join(
  quant_model_data,
  bin_model_data,
  by = c("donor_id", "Gold"),
  suffix = c("_quant", "_bin")
)

```

```{r}
library(pROC)

# Quantitative model AUC
roc_quant <- roc(merged_auc$Gold, merged_auc$pred)
auc_quant <- auc(roc_quant)

# Binary model AUC
roc_bin <- roc(merged_auc$Gold, merged_auc$solution)
auc_bin <- auc(roc_bin)

# Compare
roc.test(roc_quant, roc_bin, method = "delong")

```



```{r}
data.frame(
  Model = c("Quantitative", "Binary"),
  AUC = c(auc_quant, auc_bin),
  n_gold = sum(merged_auc$Gold == 1),
  n_nongold = sum(merged_auc$Gold == 0)
)

```



```{r}

```

