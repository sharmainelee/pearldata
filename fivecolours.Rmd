---
title: "Untitled"
output: html_document
date: "2025-07-01"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)

# 4. Ensure shell metrics are numeric
host_dat$Pearl_Harvest_Data_DVH_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_DVH_mm)
host_dat$Pearl_Harvest_Data_APW_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_APW_mm)
host_dat$Pearl_Harvest_Data_Shell_Weight_g <- as.numeric(host_dat$Pearl_Harvest_Data_Shell_Weight_g)

# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(Pearl_Harvest_Data_APW_mm),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for Gold (binary trait)
mod.ind <- asreml(
  fixed = Gold ~ Pearl_Harvest_Data_DVH_mm + Pearl_Harvest_Data_APW_mm + Pearl_Harvest_Data_Shell_Weight_g,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)


# calculate heritability on the observed scale from your animal model for a binary trait (like Gold). This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).

# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait (Gold)
p <- mean(host_dat_clean$Gold, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

#Heritability (latent scale):   0.9825 
#Heritability (observed scale): 0.2416 



# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

BLUP$prob_gold



```




```{r}


# 12. Add host ID
BLUP$host_id <- rownames(BLUP)

# 13. Plot Top and Bottom 10 BLUPs
top_bottom <- BLUP %>%
  arrange(desc(solution)) %>%
  slice(c(1:10, (n() - 9):n())) %>%
  mutate(
    host_id = factor(host_id, levels = host_id[order(solution)])
  )

ggplot(top_bottom, aes(x = host_id, y = solution)) +
  geom_col(aes(fill = solution > 0), show.legend = FALSE) +
  scale_fill_manual(values = c("firebrick", "forestgreen")) +
  coord_flip() +
  labs(
    title = "Top & Bottom 10 Host Oysters by Genetic Merit for Gold",
    x = "Host Oyster ID",
    y = "BLUP (latent scale)"
  ) +
  theme_minimal(base_size = 13)
```


```{r}
library(ggplot2)
library(dplyr)

# 1. Add host_id from rownames
BLUP$host_id <- rownames(BLUP)

# 2. Filter for host_id effects only
BLUP_filtered <- BLUP %>%
  filter(grepl("^vm\\(host_id", host_id)) %>%
  mutate(
    host_id = gsub("vm\\(host_id, ainv\\)_", "", host_id),
    prob_gold = exp(solution) / (1 + exp(solution)),
    se_prob = (exp(solution) / (1 + exp(solution))^2) * std.error  # delta method approx
  )

# 3. Top and bottom 10 by probability
top_bottom <- BLUP_filtered %>%
  arrange(desc(prob_gold)) %>%
  slice(c(1:10, (n() - 9):n())) %>%
  mutate(
    host_id = factor(host_id, levels = host_id[order(prob_gold)])
  )

# 4. Plot as dot plot with error bars
ggplot(top_bottom, aes(x = host_id, y = prob_gold)) +
  geom_point(aes(color = prob_gold > 0.5), size = 3) +
  geom_errorbar(aes(ymin = prob_gold - se_prob, ymax = prob_gold + se_prob),
                width = 0.2, alpha = 0.6) +
  coord_flip() +
  scale_color_manual(values = c("firebrick", "forestgreen")) +
  labs(
    title = "Top & Bottom 10 Host Oysters by Probability of Gold (Observed Scale)",
    x = "Host ID",
    y = "Predicted Probability of Gold Pearl"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "none")

```

```{r}
ggplot(top_bottom, aes(x = host_id, y = prob_gold)) +
  geom_segment(aes(xend = host_id, y = 0, yend = prob_gold), color = "grey70") +
  geom_point(aes(color = prob_gold > 0.5), size = 3) +
  coord_flip() +
  scale_color_manual(values = c("firebrick", "forestgreen")) +
  labs(
    title = "Top & Bottom 10 Host Oysters by Probability of Gold (Observed Scale)",
    x = "Host ID",
    y = "Predicted Probability"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "none")

```

```{r}
top_bottom <- top_bottom %>%
  mutate(prob_label = paste0(round(prob_gold * 100), "%"))

ggplot(top_bottom, aes(x = host_id, y = solution)) +
  geom_col(aes(fill = solution > 0), show.legend = FALSE) +
  geom_text(aes(label = prob_label), hjust = -0.2, size = 3.5) +
  coord_flip() +
  scale_fill_manual(values = c("firebrick", "forestgreen")) +
  labs(
    title = "Genetic Merit (Latent Scale) with Predicted Probabilities (Observed Scale)",
    x = "Host ID",
    y = "BLUP (Latent Scale)"
  ) +
  theme_minimal(base_size = 13)

```


## SILVER

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)
host_dat$First_Op_Data_Saibo_Area    <- as.factor(host_dat$First_Op_Data_Saibo_Area)

# 4. Ensure shell metrics are numeric
host_dat$First_Op_Data_Nuclei_Size_mm         <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)


# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(First_Op_Data_Saibo_Area),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for Gold (binary trait)
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm + First_Op_Data_Saibo_Area,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# calculate heritability on the observed scale from your animal model for a binary trait (like Gold). This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).



# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait (Gold)
p <- mean(host_dat_clean$Silver, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

## Heritability (latent scale):   0.9884 
## Heritability (observed scale): 0.3671

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

BLUP$prob_silver

```


```{r}
## Top & Bottom 10 Oysters
## Highlights oysters with highest/lowest breeding values for Silver production.
top_bottom <- BLUP %>%
  arrange(desc(solution)) %>%
  slice(c(1:10, (n()-9):n())) %>%
  mutate(Host_ID = rownames(.)) %>%
  mutate(Host_ID = factor(Host_ID, levels = Host_ID[order(solution)]))

ggplot(top_bottom, aes(x = Host_ID, y = solution, fill = solution > 0)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  scale_fill_manual(values = c("firebrick", "forestgreen")) +
  labs(
    title = "Top & Bottom 10 Host Oysters by Genetic Merit (Silver Trait)",
    x = "Host Oyster ID",
    y = "EBV (latent scale)"
  ) +
  theme_minimal()
```



## WHITE

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)
host_dat$First_Op_Data_Saibo_Area    <- as.factor(host_dat$First_Op_Data_Saibo_Area)

# 4. Ensure shell metrics are numeric
host_dat$Pearl_Harvest_Data_DVH_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_DVH_mm)
host_dat$Pearl_Harvest_Data_Shell_Weight_g         <- as.numeric(host_dat$Pearl_Harvest_Data_Shell_Weight_g)

# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(First_Op_Data_Saibo_Area),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for White (binary trait)
mod.ind <- asreml(
  fixed = White ~ Pearl_Harvest_Data_DVH_mm + First_Op_Data_Saibo_Area + Pearl_Harvest_Data_Shell_Weight_g,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# calculate heritability on the observed scale from your animal model for a binary trait (like Gold). This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).



# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait 
p <- mean(host_dat_clean$White, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

## Heritability (latent scale):   0.9949 
## Heritability (observed scale): 0.5813

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

BLUP$prob_white <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

BLUP$prob_white

```


```{r}

## Top & Bottom 10 Host Oysters (Bar Plot)
top_bottom <- BLUP %>%
  arrange(desc(solution)) %>%
  slice(c(1:10, (n() - 9):n())) %>%
  mutate(Host_ID = rownames(.)) %>%
  mutate(Host_ID = factor(Host_ID, levels = Host_ID[order(solution)]))

ggplot(top_bottom, aes(x = Host_ID, y = solution, fill = solution > 0)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  scale_fill_manual(values = c("firebrick", "forestgreen")) +
  labs(
    title = "Top & Bottom 10 Host Oysters by Genetic Merit (White Trait)",
    x = "Host Oyster ID",
    y = "EBV (latent scale)"
  ) +
  theme_minimal()

```





```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)

# 4. Ensure numeric
host_dat$First_Op_Data_DVH_mm         <- as.numeric(host_dat$First_Op_Data_DVH_mm)
host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)

# 5. Remove rows with missing data and check pedigree completeness
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_DVH_mm),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 6. Check if there’s variation in the trait
if (length(unique(host_dat_clean$Cream)) < 2) {
  stop("No variation in Cream trait — all values are 0 or 1.")
}

# 7. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))
ainv <- ainverse(pedind)

# 8. Fit animal model
mod.ind <- asreml(
  fixed = Cream ~ First_Op_Data_DVH_mm + First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

mod.ind <- update.asreml(mod.ind)  # 1st update
mod.ind <- update.asreml(mod.ind)  # 2nd update to ensure convergence

# 9. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # For logistic model

# 10. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 11. Prevalence and check for valid z-score
p <- mean(host_dat_clean$Cream, na.rm = TRUE)

if (p <= 0 | p >= 1) {
  warning("Trait prevalence is 0 or 1 — cannot compute observed-scale heritability.")
  h2_obs <- NA
} else {
  z <- qnorm(p)
  phi_z <- dnorm(z)
  h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
}

# 12. Report
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# 13. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$host_id <- rownames(BLUP)
BLUP$prob_cream <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

```


```{r}

## cREAM

## issues with fixed effects in model, used a simple model


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)


# 4. Ensure shell metrics are numeric
host_dat$First_Op_Data_DVH_mm         <- as.numeric(host_dat$First_Op_Data_DVH_mm)
host_dat$First_Op_Data_Nuclei_Size_mm         <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)

# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_DVH_mm),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for Cream (binary trait)
#mod.ind <- asreml(
#  fixed = Cream ~ First_Op_Data_DVH_mm + First_Op_Data_Nuclei_Size_mm,
#  random = ~ vm(host_id, ainv),
#  residual = ~ idv(units),
#  data = host_dat_clean,
#  family = asr_binomial(link = "logit")
#)

mod.ind <- asreml(
  fixed = Cream ~ 1,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# calculate heritability on the observed scale from your animal model for a binary trait (like Gold). This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).



# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait 
p <- mean(host_dat_clean$Cream, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

## Heritability (latent scale):    0.892 
## Heritability (observed scale):  0.2092

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

BLUP$prob_cream <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

BLUP$prob_cream

```



```{r}
## Top & Bottom 10 Host Oysters by EBV
top_bottom <- BLUP %>%
  arrange(desc(solution)) %>%
  slice(c(1:10, (n() - 9):n())) %>%
  mutate(Host_ID = rownames(.)) %>%
  mutate(Host_ID = factor(Host_ID, levels = Host_ID[order(solution)]))

ggplot(top_bottom, aes(x = Host_ID, y = solution, fill = solution > 0)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  scale_fill_manual(values = c("firebrick", "forestgreen")) +
  labs(
    title = "Top & Bottom 10 Host Oysters by EBV (Cream Trait)",
    x = "Host Oyster ID",
    y = "BLUP (latent scale)"
  ) +
  theme_minimal()
```



## cHAMPAGNE

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture    <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)

# 4. Ensure shell metrics are numeric



# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for champ (binary trait)
mod.ind <- asreml(
  fixed = Champ ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# calculate heritability on the observed scale from your animal model for a binary trait (like Gold). This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).



# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait 
p <- mean(host_dat_clean$Champ, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

## Heritability (latent scale):  
## Heritability (observed scale):

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

BLUP$prob_champ <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

BLUP$prob_champ

```



```{r}

## Top and Bottom 10 EBVs (Bar Plot)
top_bottom <- BLUP %>%
  arrange(desc(solution)) %>%
  slice(c(1:10, (n() - 9):n())) %>%
  mutate(Host_ID = rownames(.)) %>%
  mutate(Host_ID = factor(Host_ID, levels = Host_ID[order(solution)]))

ggplot(top_bottom, aes(x = Host_ID, y = solution, fill = solution > 0)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  scale_fill_manual(values = c("firebrick", "forestgreen")) +
  labs(
    title = "Top & Bottom 10 Host Oysters by Genetic Merit (Champagne)",
    x = "Host Oyster ID",
    y = "EBV (latent scale)"
  ) +
  theme_minimal()

```








## DONOR DAT
# SILVER

```{r}

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Create binary colour traits
donor_dat$Gold   <- ifelse(startsWith(donor_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
donor_dat$Silver <- ifelse(startsWith(donor_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
donor_dat$White  <- ifelse(startsWith(donor_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
donor_dat$Cream  <- ifelse(startsWith(donor_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
donor_dat$Champ  <- ifelse(startsWith(donor_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
donor_dat$donor_id <- as.factor(donor_dat$donor_id)
donor_dat$dam     <- as.factor(donor_dat$dam)
donor_dat$sire    <- as.factor(donor_dat$sire)
donor_dat$Matched_Donor_Data_Nacre_lip_colour_Round    <- as.factor(donor_dat$Matched_Donor_Data_Nacre_lip_colour_Round)

# 4. Ensure shell metrics are numeric
#donor_dat$Pearl_Harvest_Data_DVH_mm         <- as.numeric(donor_dat$Pearl_Harvest_Data_DVH_mm)


# 5. Remove rows with missing values in relevant columns
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(donor_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- donor_dat_clean[, c("donor_id", "sire", "dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for silver (binary trait)
mod.ind <- asreml(
  fixed = Silver ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)


# calculate heritability on the observed scale from your animal model for a binary trait (like silver). This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).

# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait (Gold)
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

#Heritability (latent scale):   
#Heritability (observed scale): 



# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

BLUP$prob_silver



```


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column name mismatches and factor conversion
donor_dat$donor_id <- as.factor(as.character(donor_dat$donor_id))
donor_dat$Dam <- as.factor(donor_dat$dam)
donor_dat$Sire <- as.factor(donor_dat$sire)

# 3. Create binary colour traits (including compound matches like "White Silver")
donor_dat$Gold   <- ifelse(grepl("Gold", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Silver <- ifelse(grepl("Silver", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$White  <- ifelse(grepl("White", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Cream  <- ifelse(grepl("Cream", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Champ  <- ifelse(grepl("Champ", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 4. Filter rows with complete relevant data
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create pedigree and inverse relationship matrix
pedind <- donor_dat_clean[, c("donor_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 6. Fit animal model for Silver
mod.ind <- asreml(
  fixed = Silver ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 7. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
vc <- summary(mod.ind)$varcomp
print(vc)

# 8. Heritability calculations
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # logistic scale residual variance
h2_latent <- Va / (Va + Ve)

p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# 9. Extract BLUPs and convert to probabilities
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))
head(BLUP)

```




## 2 July 2025

```{r}
# 1. Clean pedigree (one row per donor)
pedind <- donor_dat_clean[, c("donor_id", "Sire", "Dam")] %>%
  distinct(donor_id, .keep_all = TRUE)
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))
ainv <- ainverse(pedind)

# 2. Fit animal model with repeated saibo observations
mod <- asreml(
  fixed = Silver ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),  # genetic effect (same for all saibo from same donor)
  residual = ~ idv(units),        # residual variance per observation
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)



mod <- asreml(
  fixed = Silver ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv) + Saibo_ID,  # genetic effect (same for all saibo from same donor)
  residual = ~ idv(units),        # residual variance per observation
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)



```


```{r}
# WORKS SILVER
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors
donor_dat$donor_id <- as.factor(as.character(donor_dat$donor_id))  # Genetic ID
donor_dat$Dam <- as.factor(donor_dat$dam)
donor_dat$Sire <- as.factor(donor_dat$sire)

# 3. Create binary traits from Pearl_Grading_Data_Colour (accounting for compound names)
donor_dat$Gold   <- ifelse(grepl("Gold",   donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Silver <- ifelse(grepl("Silver", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$White  <- ifelse(grepl("White",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Cream  <- ifelse(grepl("Cream",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Champ  <- ifelse(grepl("Champ",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure pedigree columns are factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

#added this line to ensure the column is a factor:
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round)


# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Silver ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),          # Genetic effect (multiple observations allowed)
  residual = ~ idv(units),                # Independent residuals per saibo observation
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # For binary trait (e.g., Silver presence)
)

# 8. Update model to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# 10. Calculate heritability
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance on logistic scale
h2_latent <- Va / (Va + Ve)

# 11. Adjust to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# Heritability (latent scale):   0.1407
# Heritability (observed scale): 0.0744 

# 13. Extract BLUPs (random genetic solutions for each donor)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))  # Convert log-odds to probability
head(BLUP)

```

## SILVER GRAPHS







```{r}
ggplot(donor_dat_clean, aes(x = Matched_Donor_Data_Nacre_lip_colour_Round, y = Silver)) +
  geom_boxplot(fill = "lightgray", outlier.color = "red", outlier.shape = 1) +
  stat_summary(fun = mean, geom = "point", color = "blue", size = 2) +
  labs(
    title = "Silver Pearl Outcome by Donor Nacre Lip Colour",
    x = "Lip Colour",
    y = "Silver Presence (0 = No, 1 = Yes)"
  ) +
  theme_minimal(base_size = 13)

donor_dat_clean %>%
  count(Matched_Donor_Data_Nacre_lip_colour_Round) %>%
  arrange(desc(n))





```


```{r}
ggplot(
  donor_dat_clean %>% filter(Matched_Donor_Data_Nacre_lip_colour_Round != "WY"),
  aes(x = Matched_Donor_Data_Nacre_lip_colour_Round, y = Silver)
) +
  geom_boxplot(fill = "lightgray", outlier.color = "red", outlier.shape = 1) +
  stat_summary(fun = mean, geom = "point", color = "blue", size = 2) +
  labs(
    title = "Silver Pearl Outcome by Donor Nacre Lip Colour (Excl. WY)",
    x = "Lip Colour",
    y = "Silver Presence (0 = No, 1 = Yes)"
  ) +
  theme_minimal(base_size = 13)

```



```{r}
ggplot(
  donor_dat_clean %>% 
    filter(!Matched_Donor_Data_Nacre_lip_colour_Round %in% c("WY", "LGr")),
  aes(x = Matched_Donor_Data_Nacre_lip_colour_Round, y = Silver)
) +
  geom_boxplot(fill = "lightgray", outlier.color = "red", outlier.shape = 1) +
  stat_summary(fun = mean, geom = "point", color = "blue", size = 2) +
  labs(
    title = "Silver Pearl Outcome by Donor Nacre Lip Colour (Excl. WY, LGr)",
    x = "Lip Colour",
    y = "Silver Presence (0 = No, 1 = Yes)"
  ) +
  theme_minimal(base_size = 13)

```




```{r}
h2_df <- data.frame(
  Scale = c("Latent (logit)", "Observed"),
  Heritability = c(h2_latent, h2_obs)
)

ggplot(h2_df, aes(x = Scale, y = Heritability, fill = Scale)) +
  geom_col(width = 0.5) +
  geom_text(aes(label = round(Heritability, 3)), vjust = -0.5, size = 5) +
  ylim(0, max(h2_df$Heritability) + 0.1) +
  scale_fill_manual(values = c("steelblue", "darkorange")) +
  labs(
    title = "Heritability Estimates for Silver Trait",
    y = "Heritability",
    x = ""
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")

```


```{r}
library(ggplot2)
library(dplyr)

# Prepare top and bottom 10 donors by genetic merit (solution) for Silver
top_bottom_silver <- BLUP %>%
  arrange(desc(solution)) %>%
  slice(c(1:10, (n() - 9):n())) %>%
  mutate(donor_id = rownames(.)) %>%  # Add donor_id from rownames
  mutate(donor_id = factor(donor_id, levels = donor_id[order(solution)]))  # Factor for plotting order

# Plot the bar chart
ggplot(top_bottom_silver, aes(x = donor_id, y = solution, fill = solution > 0)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  scale_fill_manual(values = c("firebrick", "forestgreen")) +
  labs(
    title = "Top & Bottom 10 Donors by Genetic Merit (Silver Trait)",
    x = "Donor ID",
    y = "EBV (latent scale)"
  ) +
  theme_minimal()

```


```{r}
library(ggplot2)
library(dplyr)

# Assuming BLUP dataframe has rownames as donor IDs or donor IDs in a column (adjust if needed)
BLUP$donor_id <- rownames(BLUP)  # add donor IDs as a column if not already

# Sort by EBV (solution)
BLUP_sorted <- BLUP %>%
  arrange(solution)

# Select bottom 10 and top 10
bottom10 <- head(BLUP_sorted, 10)
top10 <- tail(BLUP_sorted, 10)

# Combine and create a label factor for ordering in plot
plot_data <- bind_rows(bottom10, top10) %>%
  mutate(donor_id = factor(donor_id, levels = donor_id))  # Keep order as is

# Create the bar plot
ggplot(plot_data, aes(x = donor_id, y = solution, fill = solution > 0)) +
  geom_bar(stat = "identity") +
  coord_flip() +  # Horizontal bars
  scale_fill_manual(values = c("TRUE" = "steelblue", "FALSE" = "tomato")) +
  labs(
    title = "Top 10 and Bottom 10 Donor EBVs for Silver Trait",
    x = "Donor ID",
    y = "EBV (log-odds scale)",
    fill = "Positive EBV"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

```




#WHITE



```{r}
#WORKS
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors
donor_dat$donor_id <- as.factor(as.character(donor_dat$donor_id))  # Genetic ID
donor_dat$Dam <- as.factor(donor_dat$dam)
donor_dat$Sire <- as.factor(donor_dat$sire)

# 3. Create binary traits from Pearl_Grading_Data_Colour (accounting for compound names)
donor_dat$Gold   <- ifelse(grepl("Gold",   donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Silver <- ifelse(grepl("Silver", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$White  <- ifelse(grepl("White",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Cream  <- ifelse(grepl("Cream",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Champ  <- ifelse(grepl("Champ",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(White),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure pedigree columns are factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

#added this line to ensure the column is a factor:
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round)


# 7. Fit the animal model
mod.ind <- asreml(
  fixed = White ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),          # Genetic effect (multiple observations allowed)
  residual = ~ idv(units),                # Independent residuals per saibo observation
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # For binary trait (e.g., white presence)
)

# 8. Update model to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# 10. Calculate heritability
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance on logistic scale
h2_latent <- Va / (Va + Ve)

# 11. Adjust to observed scale using trait prevalence
p <- mean(donor_dat_clean$White, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# Heritability (latent scale):   0.1817 
# Heritability (observed scale): 0.111

# 13. Extract BLUPs (random genetic solutions for each donor)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$prob_white <- exp(BLUP$solution) / (1 + exp(BLUP$solution))  # Convert log-odds to probability
head(BLUP)

```




## CREAM
```{r}
#WORKS
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors
donor_dat$donor_id <- as.factor(as.character(donor_dat$donor_id))  # Genetic ID
donor_dat$Dam <- as.factor(donor_dat$dam)
donor_dat$Sire <- as.factor(donor_dat$sire)

# 4. Ensure shell metrics are numeric
donor_dat$Matched_Donor_Data_DVH_mm         <- as.numeric(donor_dat$Matched_Donor_Data_DVH_mm)
donor_dat$Matched_Donor_Data_Shell_Weight_g         <- as.numeric(donor_dat$Matched_Donor_Data_Shell_Weight_g)


# 3. Create binary traits from Pearl_Grading_Data_Colour (accounting for compound names)
donor_dat$Gold   <- ifelse(grepl("Gold",   donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Silver <- ifelse(grepl("Silver", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$White  <- ifelse(grepl("White",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Cream  <- ifelse(grepl("Cream",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Champ  <- ifelse(grepl("Champ",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Cream),
    !is.na(Matched_Donor_Data_DVH_mm),
    !is.na(Matched_Donor_Data_Shell_Weight_g ),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure pedigree columns are factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)




# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Cream ~ Matched_Donor_Data_DVH_mm + Matched_Donor_Data_Shell_Weight_g,
  random = ~ vm(donor_id, ainv),          # Genetic effect (multiple observations allowed)
  residual = ~ idv(units),                # Independent residuals per saibo observation
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # For binary trait (e.g., white presence)
)

# 8. Update model to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# 10. Calculate heritability
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance on logistic scale
h2_latent <- Va / (Va + Ve)

# 11. Adjust to observed scale using trait prevalence
p <- mean(donor_dat_clean$White, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# Heritability (latent scale):   0.7079
# Heritability (observed scale):  0.4325 

# 13. Extract BLUPs (random genetic solutions for each donor)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$prob_cream <- exp(BLUP$solution) / (1 + exp(BLUP$solution))  # Convert log-odds to probability
head(BLUP)

```




#CHAMP



```{r}
#WORKS
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors
donor_dat$donor_id <- as.factor(as.character(donor_dat$donor_id))  # Genetic ID
donor_dat$Dam <- as.factor(donor_dat$dam)
donor_dat$Sire <- as.factor(donor_dat$sire)



# 3. Create binary traits from Pearl_Grading_Data_Colour (accounting for compound names)
donor_dat$Gold   <- ifelse(grepl("Gold",   donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Silver <- ifelse(grepl("Silver", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$White  <- ifelse(grepl("White",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Cream  <- ifelse(grepl("Cream",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
donor_dat$Champ  <- ifelse(grepl("Champ",  donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure pedigree columns are factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

#added this line to ensure the column is a factor:
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round)
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.factor(donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Flat)



# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Champ ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_id, ainv),          # Genetic effect (multiple observations allowed)
  residual = ~ idv(units),                # Independent residuals per saibo observation
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # For binary trait (e.g., white presence)
)

# 8. Update model to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# 10. Calculate heritability
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance on logistic scale
h2_latent <- Va / (Va + Ve)

# 11. Adjust to observed scale using trait prevalence
p <- mean(donor_dat_clean$Champ, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# Heritability (latent scale):  0.8685
# Heritability (observed scale): 0.096 

# 13. Extract BLUPs (random genetic solutions for each donor)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$prob_champ <- exp(BLUP$solution) / (1 + exp(BLUP$solution))  # Convert log-odds to probability
head(BLUP)

```

###
7 July 


Silver
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors - ensure unique IDs
# Create unique IDs by prefixing with type
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(paste0("D_", donor_id)),
    dam = ifelse(is.na(dam), NA, paste0("M_", dam)),
    sire = ifelse(is.na(sire), NA, paste0("F_", sire))
  )

# Convert to factors
donor_dat$donor_id <- as.factor(donor_dat$donor_id)
donor_dat$Dam <- as.factor(donor_dat$dam)
donor_dat$Sire <- as.factor(donor_dat$sire)

# 3. Create binary traits from Pearl_Grading_Data_Colour
donor_dat$Silver <- ifelse(grepl("Silver", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(donor_id),
    !is.na(Sire) | !is.na(Dam)  # Need at least one parent
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(ID = donor_id, SIRE = Sire, DAM = Dam) %>%
  mutate(
    SIRE = ifelse(is.na(SIRE), "0", as.character(SIRE)),
    DAM = ifelse(is.na(DAM), "0", as.character(DAM))
  )

# Ensure all IDs are unique and properly formatted
all_ids <- unique(c(levels(pedind$ID), levels(pedind$SIRE), levels(pedind$DAM)))
pedind <- pedind %>%
  mutate(
    ID = factor(ID, levels = all_ids),
    SIRE = factor(SIRE, levels = all_ids),
    DAM = factor(DAM, levels = all_ids)
  )

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Ensure the fixed effect is a factor
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(
  donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round
)

# 8. Fit the animal model
mod.ind <- asreml(
  fixed = Silver ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),          # Genetic effect
  residual = ~ idv(units),                # Independent residuals
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # For binary trait
)

# 9. Update model to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 10. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# 11. Calculate heritability
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance on logistic scale
h2_latent <- Va / (Va + Ve)

# 12. Adjust to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 13. Print heritability results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# 14. Extract BLUPs (random genetic solutions for each donor)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))
head(BLUP)
```




## graphs for silver

```{r}
library(ggplot2)

# Add donor_id as a column if it's currently row names
BLUP$donor_id <- rownames(BLUP)

# Filter only donor_id terms (exclude other random terms if present)
BLUP_filtered <- BLUP %>%
  filter(grepl("^vm\\(donor_id", rownames(BLUP)))

# Clean up donor_id names
BLUP_filtered$donor_id <- gsub("vm\\(donor_id, ainv\\)_", "", rownames(BLUP_filtered))

# Get top and bottom 10
top10 <- BLUP_filtered %>% arrange(desc(solution)) %>% slice(1:10)
bottom10 <- BLUP_filtered %>% arrange(solution) %>% slice(1:10)

# Combine for plotting
top_bottom <- bind_rows(top10, bottom10) %>%
  mutate(rank_group = ifelse(solution >= 0, "Top 10", "Bottom 10"))

# Plot
ggplot(top_bottom, aes(x = reorder(donor_id, solution), y = solution, fill = rank_group)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  labs(
    title = "Top and Bottom 10 Donors by Genetic Merit for Silver Trait",
    x = "Donor ID",
    y = "BLUP (Genetic Merit)"
  ) +
  scale_fill_manual(values = c("Top 10" = "#1b9e77", "Bottom 10" = "#d95f02")) +
  theme_minimal()

```




## white


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors - ensure unique IDs
# Create unique IDs by prefixing with type
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(paste0("D_", donor_id)),
    dam = ifelse(is.na(dam), NA, paste0("M_", dam)),
    sire = ifelse(is.na(sire), NA, paste0("F_", sire))
  )

# Convert to factors
donor_dat$donor_id <- as.factor(donor_dat$donor_id)
donor_dat$Dam <- as.factor(donor_dat$dam)
donor_dat$Sire <- as.factor(donor_dat$sire)

# 3. Create binary traits from Pearl_Grading_Data_Colour
donor_dat$White <- ifelse(grepl("White", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(White),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(donor_id),
    !is.na(Sire) | !is.na(Dam)  # Need at least one parent
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(ID = donor_id, SIRE = Sire, DAM = Dam) %>%
  mutate(
    SIRE = ifelse(is.na(SIRE), "0", as.character(SIRE)),
    DAM = ifelse(is.na(DAM), "0", as.character(DAM))
  )

# Ensure all IDs are unique and properly formatted
all_ids <- unique(c(levels(pedind$ID), levels(pedind$SIRE), levels(pedind$DAM)))
pedind <- pedind %>%
  mutate(
    ID = factor(ID, levels = all_ids),
    SIRE = factor(SIRE, levels = all_ids),
    DAM = factor(DAM, levels = all_ids)
  )

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Ensure the fixed effect is a factor
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(
  donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round
)

# 8. Fit the animal model
mod.ind <- asreml(
  fixed = White ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),          # Genetic effect
  residual = ~ idv(units),                # Independent residuals
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # For binary trait
)

# 9. Update model to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 10. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# 11. Calculate heritability
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance on logistic scale
h2_latent <- Va / (Va + Ve)

# 12. Adjust to observed scale using trait prevalence
p <- mean(donor_dat_clean$White, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 13. Print heritability results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# 14. Extract BLUPs (random genetic solutions for each donor)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$prob_white <- exp(BLUP$solution) / (1 + exp(BLUP$solution))
head(BLUP)
```

## white graphs


```{r}
library(ggplot2)
library(dplyr)

# Ensure donor_id is extracted and cleaned
BLUP$donor_id <- rownames(BLUP)

# Filter only donor_id BLUPs
BLUP_filtered <- BLUP %>%
  filter(grepl("^vm\\(donor_id", donor_id))

# Clean the donor_id name for plotting
BLUP_filtered$donor_id <- gsub("vm\\(donor_id, ainv\\)_", "", BLUP_filtered$donor_id)

# Get top and bottom 10 donors by BLUP (genetic merit)
top10 <- BLUP_filtered %>% arrange(desc(solution)) %>% slice(1:10)
bottom10 <- BLUP_filtered %>% arrange(solution) %>% slice(1:10)

# Combine both for plotting
top_bottom <- bind_rows(top10, bottom10) %>%
  mutate(rank_group = ifelse(solution >= 0, "Top 10", "Bottom 10"))

# Create the bar plot
ggplot(top_bottom, aes(x = reorder(donor_id, solution), y = solution, fill = rank_group)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  labs(
    title = "Top and Bottom 10 Donors by Genetic Merit for White Trait",
    x = "Donor ID",
    y = "BLUP (Genetic Merit for White)"
  ) +
  scale_fill_manual(values = c("Top 10" = "#377eb8", "Bottom 10" = "#e41a1c")) +
  theme_minimal()

```



# cream
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors - ensure unique IDs
# Create unique IDs by prefixing with type
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(paste0("D_", donor_id)),
    dam = ifelse(is.na(dam), NA, paste0("M_", dam)),
    sire = ifelse(is.na(sire), NA, paste0("F_", sire))
  )

# Convert to factors
donor_dat$donor_id <- as.factor(donor_dat$donor_id)
donor_dat$Dam <- as.factor(donor_dat$dam)
donor_dat$Sire <- as.factor(donor_dat$sire)

# 3. Ensure shell metrics are numeric
donor_dat$Matched_Donor_Data_DVH_mm <- as.numeric(donor_dat$Matched_Donor_Data_DVH_mm)
donor_dat$Matched_Donor_Data_Shell_Weight_g <- as.numeric(donor_dat$Matched_Donor_Data_Shell_Weight_g)

# 4. Create binary traits from Pearl_Grading_Data_Colour
donor_dat$Cream <- ifelse(grepl("Cream", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 5. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Cream),
    !is.na(Matched_Donor_Data_DVH_mm),
    !is.na(Matched_Donor_Data_Shell_Weight_g),
    !is.na(donor_id),
    !is.na(Sire) | !is.na(Dam)  # Need at least one parent
  )

# 6. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(ID = donor_id, SIRE = Sire, DAM = Dam) %>%
  mutate(
    SIRE = ifelse(is.na(SIRE), "0", as.character(SIRE)),
    DAM = ifelse(is.na(DAM), "0", as.character(DAM))
  )

# Ensure all IDs are unique and properly formatted
all_ids <- unique(c(levels(pedind$ID), levels(pedind$SIRE), levels(pedind$DAM)))
pedind <- pedind %>%
  mutate(
    ID = factor(ID, levels = all_ids),
    SIRE = factor(SIRE, levels = all_ids),
    DAM = factor(DAM, levels = all_ids)
  )

# 7. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 8. Fit the animal model
mod.ind <- asreml(
  fixed = Cream ~ Matched_Donor_Data_DVH_mm + Matched_Donor_Data_Shell_Weight_g,
  random = ~ vm(donor_id, ainv),          # Genetic effect
  residual = ~ idv(units),                # Independent residuals
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # For binary trait
)

# 9. Update model to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 10. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# 11. Calculate heritability
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance on logistic scale
h2_latent <- Va / (Va + Ve)

# 12. Adjust to observed scale using trait prevalence
p <- mean(donor_dat_clean$Cream, na.rm = TRUE)  # Fixed to use Cream instead of White
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 13. Print heritability results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# 14. Extract BLUPs (random genetic solutions for each donor)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$prob_cream <- exp(BLUP$solution) / (1 + exp(BLUP$solution))
head(BLUP)
```
#cream graphs 

```{r}


library(ggplot2)
library(dplyr)

# Add donor_id as a column from rownames
BLUP$donor_id <- rownames(BLUP)

# Filter for genetic BLUPs only (exclude any other random effects)
BLUP_filtered <- BLUP %>%
  filter(grepl("^vm\\(donor_id", donor_id))

# Clean up donor_id labels
BLUP_filtered$donor_id <- gsub("vm\\(donor_id, ainv\\)_", "", BLUP_filtered$donor_id)

# Get top 10 and bottom 10 donor BLUPs
top10 <- BLUP_filtered %>% arrange(desc(solution)) %>% slice(1:10)
bottom10 <- BLUP_filtered %>% arrange(solution) %>% slice(1:10)

# Combine for plotting
top_bottom <- bind_rows(top10, bottom10) %>%
  mutate(rank_group = ifelse(solution >= 0, "Top 10", "Bottom 10"))

# Create bar plot
ggplot(top_bottom, aes(x = reorder(donor_id, solution), y = solution, fill = rank_group)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  labs(
    title = "Top and Bottom 10 Donors by Genetic Merit for Cream Trait",
    x = "Donor ID",
    y = "BLUP (Genetic Merit for Cream)"
  ) +
  scale_fill_manual(values = c("Top 10" = "#984ea3", "Bottom 10" = "#ff7f00")) +
  theme_minimal()



```



## champ

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors - ensure unique IDs
# Create unique IDs by prefixing with type
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(paste0("D_", donor_id)),
    dam = ifelse(is.na(dam), NA, paste0("M_", dam)),
    sire = ifelse(is.na(sire), NA, paste0("F_", sire))
  )

# Convert to factors
donor_dat$donor_id <- as.factor(donor_dat$donor_id)
donor_dat$Dam <- as.factor(donor_dat$dam)
donor_dat$Sire <- as.factor(donor_dat$sire)

# 3. Create binary traits from Pearl_Grading_Data_Colour
donor_dat$Champ <- ifelse(grepl("Champ", donor_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(donor_id),
    !is.na(Sire) | !is.na(Dam)  # Need at least one parent
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(ID = donor_id, SIRE = Sire, DAM = Dam) %>%
  mutate(
    SIRE = ifelse(is.na(SIRE), "0", as.character(SIRE)),
    DAM = ifelse(is.na(DAM), "0", as.character(DAM))
  )

# Ensure all IDs are unique and properly formatted
all_ids <- unique(c(levels(pedind$ID), levels(pedind$SIRE), levels(pedind$DAM)))
pedind <- pedind %>%
  mutate(
    ID = factor(ID, levels = all_ids),
    SIRE = factor(SIRE, levels = all_ids),
    DAM = factor(DAM, levels = all_ids)
  )

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Ensure fixed effects are factors
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(
  donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round
)
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.factor(
  donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Flat
)

# 8. Fit the animal model
mod.ind <- asreml(
  fixed = Champ ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_id, ainv),          # Genetic effect
  residual = ~ idv(units),                # Independent residuals
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # For binary trait
)

# 9. Update model to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 10. Extract variance components
vc <- summary(mod.ind)$varcomp
print(vc)

# 11. Calculate heritability
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance on logistic scale
h2_latent <- Va / (Va + Ve)

# 12. Adjust to observed scale using trait prevalence
p <- mean(donor_dat_clean$Champ, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 13. Print heritability results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# 14. Extract BLUPs (random genetic solutions for each donor)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$prob_champ <- exp(BLUP$solution) / (1 + exp(BLUP$solution))
head(BLUP)
```





## champ graphs

```{r}
library(ggplot2)
library(dplyr)

# Step 1: Extract donor IDs from rownames
BLUP$donor_id <- rownames(BLUP)

# Step 2: Filter for donor_id effects only
BLUP_filtered <- BLUP %>%
  filter(grepl("^vm\\(donor_id", donor_id))

# Step 3: Clean donor_id names
BLUP_filtered$donor_id <- gsub("vm\\(donor_id, ainv\\)_", "", BLUP_filtered$donor_id)

# Step 4: Select top 10 and bottom 10 based on genetic merit (BLUP)
top10 <- BLUP_filtered %>% arrange(desc(solution)) %>% slice(1:10)
bottom10 <- BLUP_filtered %>% arrange(solution) %>% slice(1:10)

# Step 5: Combine and label groups
top_bottom <- bind_rows(top10, bottom10) %>%
  mutate(rank_group = ifelse(solution >= 0, "Top 10", "Bottom 10"))

# Step 6: Plot using ggplot2
ggplot(top_bottom, aes(x = reorder(donor_id, solution), y = solution, fill = rank_group)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  labs(
    title = "Top and Bottom 10 Donors by Genetic Merit for Champagne Trait",
    x = "Donor ID",
    y = "BLUP (Genetic Merit for Champagne)"
  ) +
  scale_fill_manual(values = c("Top 10" = "#a65628", "Bottom 10" = "#f781bf")) +
  theme_minimal()

```






