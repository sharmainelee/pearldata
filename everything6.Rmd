---
title: "everything6"
output: html_document
date: "2025-08-28"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 1. Proportion

#startswith include gold overtone e.g gold silver, gold white

```{r}
dat <- PearlOperationalData

# Convert Colour to character (avoids factor issues)
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove oysters with no pearls (missing or blank)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary Gold variable
dat$Gold <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)

# Convert Saibo donor ID to factor
dat$First_Op_Data_Saibo_No <- as.factor(dat$First_Op_Data_Saibo_No)

# Fit logistic regression
model <- glm(Gold ~ First_Op_Data_Saibo_No, data = dat, family = binomial)
summary(model)

```


#gold + gold overtones
```{r}
library(ggplot2)
library(dplyr)

# Calculate proportion of gold pearls per donor
prop_data <- dat %>%
  group_by(First_Op_Data_Saibo_No) %>%
  summarise(
    n = n(),
    gold_rate = mean(Gold)
  )

# Bar plot
p_gold <- ggplot(prop_data, aes(x = First_Op_Data_Saibo_No, y = gold_rate)) +
  geom_col(fill = "goldenrod") +
  labs(
    x = "Saibo Donor ID",
    y = "Proportion of Gold Pearls",
    title = "Proportion of Gold Pearls by Saibo Donor"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_gold

```


###silver + overtones silver gold, silver pink, silver white

```{r}
dat <- PearlOperationalData

# Convert Colour to character (avoids factor issues)
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove oysters with no pearls (missing or blank)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary Gold variable
dat$Silver <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)

# Convert Saibo donor ID to factor
dat$First_Op_Data_Saibo_No <- as.factor(dat$First_Op_Data_Saibo_No)

# Fit logistic regression
model <- glm(Silver ~ First_Op_Data_Saibo_No, data = dat, family = binomial)
summary(model)

```


#silver + overtones

```{r}
library(ggplot2)
library(dplyr)

# Calculate proportion of gold pearls per donor
prop_data <- dat %>%
  group_by(First_Op_Data_Saibo_No) %>%
  summarise(
    n = n(),
    silver_rate = mean(Silver)
  )

# Bar plot
p_silver <- ggplot(prop_data, aes(x = First_Op_Data_Saibo_No, y = silver_rate)) +
  geom_col(fill = "#c0c0c0") +
  labs(
    x = "Saibo Donor ID",
    y = "Proportion of Silver Pearls",
    title = "Proportion of Silver Pearls by Saibo Donor"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_silver

```



# white + overtones white cream, white gold, white pink, white silver

```{r}
dat <- PearlOperationalData

# Convert Colour to character (avoids factor issues)
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove oysters with no pearls (missing or blank)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary Gold variable
dat$White <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "White"), 1, 0)

# Convert Saibo donor ID to factor
dat$First_Op_Data_Saibo_No <- as.factor(dat$First_Op_Data_Saibo_No)

# Fit logistic regression
model <- glm(White ~ First_Op_Data_Saibo_No, data = dat, family = binomial)
summary(model)

```

#white + overtones

```{r}
library(ggplot2)
library(dplyr)

# Calculate proportion of gold pearls per donor
prop_data <- dat %>%
  group_by(First_Op_Data_Saibo_No) %>%
  summarise(
    n = n(),
    white_rate = mean(White)
  )

# Bar plot
p_white <- ggplot(prop_data, aes(x = First_Op_Data_Saibo_No, y = white_rate)) +
  geom_col(fill = "#E3DAC9") +
  labs(
    x = "Saibo Donor ID",
    y = "Proportion of White Pearls",
    title = "Proportion of White Pearls by Saibo Donor"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_white

```



# cream 

```{r}
dat <- PearlOperationalData

# Convert Colour to character (avoids factor issues)
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove oysters with no pearls (missing or blank)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary Gold variable
dat$Cream <- ifelse(startsWith(dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)

# Convert Saibo donor ID to factor
dat$First_Op_Data_Saibo_No <- as.factor(dat$First_Op_Data_Saibo_No)

# Fit logistic regression
model <- glm(Cream ~ First_Op_Data_Saibo_No, data = dat, family = binomial)
summary(model)

```


#cream 

```{r}
library(ggplot2)
library(dplyr)

# Calculate proportion of cream pearls per donor
prop_data <- dat %>%
  group_by(First_Op_Data_Saibo_No) %>%
  summarise(
    n = n(),
    cream_rate = mean(Cream)
  )

# Bar plot
p_cream <- ggplot(prop_data, aes(x = First_Op_Data_Saibo_No, y = cream_rate)) +
  geom_col(fill = "#FFFDD0") +
  labs(
    x = "Saibo Donor ID",
    y = "Proportion of Cream Pearls",
    title = "Proportion of Cream Pearls by Saibo Donor"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_cream

```



# champagne

```{r}
dat <- PearlOperationalData

# Convert Colour to character (avoids factor issues)
dat$Pearl_Grading_Data_Colour <- as.character(dat$Pearl_Grading_Data_Colour)

# Remove oysters with no pearls (missing or blank)
dat <- dat[!is.na(dat$Pearl_Grading_Data_Colour) & dat$Pearl_Grading_Data_Colour != "", ]

# Create binary Gold variable
dat$Champ <- ifelse(grepl("Champ",dat$Pearl_Grading_Data_Colour), 1, 0)

# Convert Saibo donor ID to factor
dat$First_Op_Data_Saibo_No <- as.factor(dat$First_Op_Data_Saibo_No)

# Fit logistic regression
model <- glm(Champ ~ First_Op_Data_Saibo_No, data = dat, family = binomial)
summary(model)

```


#champagne and light champ

```{r}
library(ggplot2)
library(dplyr)

# Calculate proportion of champ pearls per donor
prop_data <- dat %>%
  group_by(First_Op_Data_Saibo_No) %>%
  summarise(
    n = n(),
    champ_rate = mean(Champ)
  )

# Bar plot
p_champ <- ggplot(prop_data, aes(x = First_Op_Data_Saibo_No, y = champ_rate)) +
  geom_col(fill = "#F7E7CE") +
  labs(
    x = "Saibo Donor ID",
    y = "Proportion of Champagne Pearls",
    title = "Proportion of Champagne Pearls by Saibo Donor"
  ) +
  scale_y_continuous(labels = scales::percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p_champ

```

#stacked plot

```{r}
library(dplyr)
library(stringr)
library(ggplot2)
library(scales)

# Start with your dataset
dat <- PearlOperationalData

# Clean and classify base colours (includes overtones)
dat <- dat %>%
  filter(!is.na(Pearl_Grading_Data_Colour),
         Pearl_Grading_Data_Colour != "") %>%
  mutate(
    base_colour = case_when(
      str_detect(Pearl_Grading_Data_Colour, regex("^Gold", ignore_case = TRUE)) ~ "Gold",
      str_detect(Pearl_Grading_Data_Colour, regex("^Silver", ignore_case = TRUE)) ~ "Silver",
      str_detect(Pearl_Grading_Data_Colour, regex("^White", ignore_case = TRUE)) ~ "White",
      str_detect(Pearl_Grading_Data_Colour, regex("^Cream", ignore_case = TRUE)) ~ "Cream",
      str_detect(Pearl_Grading_Data_Colour, regex("Champ", ignore_case = TRUE)) ~ "Champagne",
      TRUE ~ NA_character_
    ),
    First_Op_Data_Saibo_No = as.factor(First_Op_Data_Saibo_No)
  ) %>%
  filter(!is.na(base_colour))

# Ensure legend order
dat$base_colour <- factor(dat$base_colour,
                          levels = c("Gold", "Silver", "White", "Cream", "Champagne"))

# Count and calculate proportions per donor
stack_df <- dat %>%
  count(First_Op_Data_Saibo_No, base_colour, name = "n") %>%
  group_by(First_Op_Data_Saibo_No) %>%
  mutate(prop = n / sum(n)) %>%
  ungroup()

# 100% stacked bar plot with custom colours
ggplot(stack_df, aes(x = First_Op_Data_Saibo_No, y = prop, fill = base_colour)) +
  geom_col(width = 0.9) +
  scale_fill_manual(
    values = c(
      "Gold" = "#ffd700",
      "Silver" = "#696969",
      "White" = "#d3d3d3",
      "Cream" = "#fffacd",
      "Champagne" = "#ffa07a"
    )
  ) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(
    x = "Saibo Donor ID",
    y = "Pearl Colour Composition (%)",
    fill = "Base colour",
    title = "Pearl colour composition per Saibo donor (startswith grouping)"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

```






#Gold binary host - No fixed effects

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Gold ~ 1,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Gold)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Gold binary host - fixed effects: First_Op_Data_Nuclei_Size_mm


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Gold ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Gold)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```




# Gold binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors


host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Gold ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Gold)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Gold binary host - fixed effects:  Matched_Donor_Data_Saibo_No

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Gold ~ Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Gold)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)


```



# Gold binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Gold ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Gold)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Gold binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No

## BEST

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Gold ~ First_Op_Data_Nuclei_Size_mm + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Gold)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```

# Gold binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Gold ~ Pearl_Harvest_Data_Days_of_Pearl_Culture + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Gold)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Gold binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Gold ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Gold)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```





# Silver binary host - no fixed effects 
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Silver ~ 1,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Silver)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```

# Silver binary host - fixed effects: First_Op_Data_Nuclei_Size_mm


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Silver)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```

# Silver binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors


host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Silver ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Silver)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Silver binary host - fixed effects:  Matched_Donor_Data_Saibo_No



```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Silver ~ Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Silver)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)


```

# Silver binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Silver)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```

# Silver binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Silver)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Silver binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No



```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Silver ~ Pearl_Harvest_Data_Days_of_Pearl_Culture + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Silver)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```



# Silver binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Silver)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```




# White binary host - no fixed effects 

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = White ~ 1,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$White)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```

# White binary host - fixed effects: First_Op_Data_Nuclei_Size_mm


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = White ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$White)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# White binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors


host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = White ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$White)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# White binary host - fixed effects:  Matched_Donor_Data_Saibo_No

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = White ~ Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$White)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)


```

# White binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = White ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$White)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# White binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = White ~ First_Op_Data_Nuclei_Size_mm + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$White)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# White binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = White ~ Pearl_Harvest_Data_Days_of_Pearl_Culture + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$White)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# White binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = White ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$White)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```




# Cream binary host - no fixed effects 

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Cream ~ 1,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Cream)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Cream binary host - fixed effects: First_Op_Data_Nuclei_Size_mm
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Cream ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Cream)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```

# Cream binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors


host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Cream ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Cream)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```

# Cream binary host - fixed effects:  Matched_Donor_Data_Saibo_No

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Cream ~ Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Cream)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)


```


# Cream binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Cream ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Cream)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```

# Cream binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Cream ~ First_Op_Data_Nuclei_Size_mm + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Cream)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Cream binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Cream ~ Pearl_Harvest_Data_Days_of_Pearl_Culture + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Cream)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```

# Cream binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Cream ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Cream)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```




# Champagne binary host - no fixed effects 
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Champ ~ 1,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Champ)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```

# Champagne binary host - fixed effects: First_Op_Data_Nuclei_Size_mm

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Champ ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Champ)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Champagne binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors


host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Champ ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Champ)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Champagne binary host - fixed effects:  Matched_Donor_Data_Saibo_No

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Champ ~ Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Champ)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)


```


# Champagne binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Champ ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Champ)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```



# Champagne binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Champ ~ First_Op_Data_Nuclei_Size_mm + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Champ)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


# Champagne binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Champ ~ Pearl_Harvest_Data_Days_of_Pearl_Culture + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Champ)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```



# Champagne binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No


```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and prepare data
host_dat <- host_id2

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(grepl("^Gold", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Silver <- ifelse(grepl("^Silver", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$White  <- ifelse(grepl("^White", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Cream  <- ifelse(grepl("^Cream", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
host_dat$Champ  <- ifelse(grepl("^Champ", host_dat$Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)

# 3. Rename and format ID columns as factors
host_dat <- host_dat %>%
  rename(
    host_id = Shell_Metrics_GenotypeID_DART,
    Dam = host_Dam,
    Sire = host_Sire
  ) %>%
  mutate(
    host_id = as.factor(host_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 4. shell metrics and factors

host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)
host_dat$Matched_Donor_Data_Saibo_No <- as.factor(host_dat$Matched_Donor_Data_Saibo_No)


# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(Matched_Donor_Data_Saibo_No),
    !is.na(host_id)
  )

# 6. Create pedigree
pedind <- host_dat_clean %>%
  select(ID = host_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

ainv <- ainverse(pedind)

# 7. Fit ASReml binary model for Gold
mod.ind <- asreml(
  fixed = Champ ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture + Matched_Donor_Data_Saibo_No,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


#vpredict(mod.ind, h2 ~ V1 / (V1 + (pi^2 / 3)))

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- (pi^2) / 3  # Logistic residual variance

# Latent scale heritability
h2_latent <- Va / (Va + Ve)
dVa <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# Observed scale heritability
p <- mean(host_dat_clean$Champ)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("SE (latent scale):", round(SE_h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")
cat("SE (observed scale):", round(SE_obs, 4), "\n")

# Heritability summary
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_obs)
)

print(herit_summary)

# Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

```


























# Gold binary donor - no fixed effects


```{r}
# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ 1,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```

# Gold binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm

```{r}
# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$First_Op_Data_Nuclei_Size_mm <- as.factor(donor_dat$First_Op_Data_Nuclei_Size_mm)



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# Gold binary donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}
# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# Gold binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture


```{r}
# DONOR GOLD

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$First_Op_Data_Nuclei_Size_mm <- as.factor(donor_dat$First_Op_Data_Nuclei_Size_mm)
donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)


# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```





# Silver binary donor - no fixed effects

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Silver ~ 1,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```





# Silver binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$First_Op_Data_Nuclei_Size_mm <- as.factor(donor_dat$First_Op_Data_Nuclei_Size_mm)



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# Silver binary donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Silver ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```

# Silver binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture


```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$First_Op_Data_Nuclei_Size_mm <- as.factor(donor_dat$First_Op_Data_Nuclei_Size_mm)
donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)


# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```



# White binary donor - no fixed effects

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(White),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = White ~ 1,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$White, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# White binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$First_Op_Data_Nuclei_Size_mm <- as.factor(donor_dat$First_Op_Data_Nuclei_Size_mm)



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(White),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = White ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$White, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# White binary donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(White),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = White ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$White, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# White binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$First_Op_Data_Nuclei_Size_mm <- as.factor(donor_dat$First_Op_Data_Nuclei_Size_mm)
donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)


# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(White),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = White ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$White, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```



# Cream binary donor - no fixed effects

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Cream),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Cream ~ 1,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Cream, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# Cream binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm


```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$First_Op_Data_Nuclei_Size_mm <- as.factor(donor_dat$First_Op_Data_Nuclei_Size_mm)



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Cream ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Cream, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# Cream binary donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Cream),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Cream ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Cream, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# Cream binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$First_Op_Data_Nuclei_Size_mm <- as.factor(donor_dat$First_Op_Data_Nuclei_Size_mm)
donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)


# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Cream ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Cream, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# Champagne binary donor - no fixed effects

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Champ),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Champ ~ 1,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Champ, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```


# Champagne binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$First_Op_Data_Nuclei_Size_mm <- as.factor(donor_dat$First_Op_Data_Nuclei_Size_mm)



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Champ),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Champ ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Champ, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```
# Champagne binary donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture
```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)



# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Champ ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Champ, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```

# Champagne binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
#donor_dat <- read_csv("donor_data.csv")
donor_dat <- donor_data2


# 3. Rename and format ID columns as factors
donor_dat <- donor_dat %>%
  rename(
    donor_id = Matched_Donor_Data_Saibo_No,
    Dam = `Candidate mother ID`,
    Sire = `Candidate father ID`
  ) %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam     = as.factor(Dam),
    Sire    = as.factor(Sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
     )

# 4. shell metrics and factors
donor_dat$First_Op_Data_Nuclei_Size_mm <- as.factor(donor_dat$First_Op_Data_Nuclei_Size_mm)
donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture <- as.factor(donor_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)


# 5. Remove rows with missing values
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Champ),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(donor_id)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Fit the animal model
mod.ind <- asreml(
  fixed = Champ ~ First_Op_Data_Nuclei_Size_mm + Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# Calculating heritability
#vpredict(mod.ind,h2~V1/(V1+V2))

# 10. Calculate heritability (latent scale)
Va    <- vc["vm(donor_id, ainv)", "component"]
SE_Va <- vc["vm(donor_id, ainv)", "std.error"]
Ve    <- (pi^2)/3
h2_latent <- Va / (Va + Ve)

# Standard error using delta method
dVa          <- Ve / (Va + Ve)^2
SE_h2_latent <- SE_Va * dVa

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Champ, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

h2_obs    <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_h2_obs <- (SE_h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates and SEs
cat("Heritability (latent scale):       ", h2_latent, "\n")
cat("Standard Error (latent scale):     ", SE_h2_latent, "\n")
cat("Heritability (observed scale):     ", h2_obs, "\n")
cat("Standard Error (observed scale):   ", SE_h2_obs, "\n")

# Create a summary table
herit_summary <- data.frame(
  Scale = c("Latent", "Observed"),
  Heritability = c(h2_latent, h2_obs),
  Std_Error = c(SE_h2_latent, SE_h2_obs)
)

# Print the table
print(herit_summary)


# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
#actual_ids <- unique(donor_dat_clean$donor_id)
#BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
#BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)



```

#VPREDICT 

# Gold quantitative host - no fixed effects
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
host_dat <- hostquant2 %>%
  filter(
    !is.na(Shell_Metrics_GenotypeID_DART),
    !is.na(host_Dam),
    !is.na(host_Sire),
    !is.na(pred)
  )

# Convert ID columns and fixed effects
host_dat <- host_dat %>%
  mutate(
    offspring_id_host = as.factor(Shell_Metrics_GenotypeID_DART),
    dam_host = as.factor(host_Dam),
    sire_host = as.factor(host_Sire),

  )

# Drop unused factor levels
host_dat <- droplevels(host_dat)

# Filter for complete cases needed for the model
host_dat_clean <- host_dat %>%
  filter(complete.cases(
    pred,
    offspring_id_host
  ))

# Add 'units' column
host_dat_clean$units <- 1:nrow(host_dat_clean)

# Prepare pedigree and inverse
ped <- host_dat_clean %>%
  select(ID = offspring_id_host, SIRE = sire_host, DAM = dam_host) %>%
  distinct(ID, .keep_all = TRUE)  # Remove duplicated IDs
ped <- data.frame(lapply(ped, as.factor))



ainv <- ainverse(ped)

# Fit Gaussian animal model with ASReml
mod_host <- asreml(
  fixed = pred ~ 1,
  random = ~ vm(offspring_id_host, ainv),
  residual = ~ idv(units),
  data = host_dat_clean
)

# Update and extract variance components
mod_host <- update.asreml(mod_host)
summary(mod_host)$varcomp

# Update model again to ensure convergence
mod_host <- update.asreml(mod_host)


# Extract variance components
vc <- summary(mod_host)$varcomp
print(vc)

# Calculate heritability
vpredict(mod_host, h2 ~ V1 / (V1 + V2))

# Extract BLUPs

blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
head(blup_host)

#blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
#blup_host$host <- gsub("^.*\\)_", "", rownames(blup_host))
#blup_host <- blup_host %>%
#filter(host %in% unique(host_dat_clean$offspring_id_host)) %>%
#mutate(EBV = solution)

# View top 10 BLUPs
#head(blup_host[order(-blup_host$EBV), ], 10)

```




# Gold quantitative host - fixed effects: First_Op_Data_Nuclei_Size_mm
```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
host_dat <- hostquant2 %>%
  filter(
    !is.na(Shell_Metrics_GenotypeID_DART),
    !is.na(host_Dam),
    !is.na(host_Sire),
    !is.na(pred)
  )

# Convert ID columns and fixed effects
host_dat <- host_dat %>%
  mutate(
    offspring_id_host = as.factor(Shell_Metrics_GenotypeID_DART),
    dam_host = as.factor(host_Dam),
    sire_host = as.factor(host_Sire),

    # Fixed effects
    First_Op_Data_Nuclei_Size_mm = as.numeric(First_Op_Data_Nuclei_Size_mm)
  )

# Drop unused factor levels
host_dat <- droplevels(host_dat)

# Filter for complete cases needed for the model
host_dat_clean <- host_dat %>%
  filter(complete.cases(
    pred,
    offspring_id_host,
    First_Op_Data_Nuclei_Size_mm
  ))

# Add 'units' column
host_dat_clean$units <- 1:nrow(host_dat_clean)

# Prepare pedigree and inverse
ped <- host_dat_clean %>%
  select(ID = offspring_id_host, SIRE = sire_host, DAM = dam_host) %>%
  distinct(ID, .keep_all = TRUE)  # Remove duplicated IDs
ped <- data.frame(lapply(ped, as.factor))



ainv <- ainverse(ped)

# Fit Gaussian animal model with ASReml
mod_host <- asreml(
  fixed = pred ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(offspring_id_host, ainv),
  residual = ~ idv(units),
  data = host_dat_clean
)

# Update and extract variance components
mod_host <- update.asreml(mod_host)
summary(mod_host)$varcomp

# Update model again to ensure convergence
mod_host <- update.asreml(mod_host)


# Extract variance components
vc <- summary(mod_host)$varcomp
print(vc)

# Calculate heritability
vpredict(mod_host, h2 ~ V1 / (V1 + V2))

# Extract BLUPs

blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
head(blup_host)

#blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
#blup_host$host <- gsub("^.*\\)_", "", rownames(blup_host))
#blup_host <- blup_host %>%
#filter(host %in% unique(host_dat_clean$offspring_id_host)) %>%
#mutate(EBV = solution)

# View top 10 BLUPs
#head(blup_host[order(-blup_host$EBV), ], 10)

```



# Gold quantitative host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
host_dat <- hostquant2 %>%
  filter(
    !is.na(Shell_Metrics_GenotypeID_DART),
    !is.na(host_Dam),
    !is.na(host_Sire),
    !is.na(pred)
  )

# Convert ID columns and fixed effects
host_dat <- host_dat %>%
  mutate(
    offspring_id_host = as.factor(Shell_Metrics_GenotypeID_DART),
    dam_host = as.factor(host_Dam),
    sire_host = as.factor(host_Sire),

    # Fixed effects

    Pearl_Harvest_Data_Days_of_Pearl_Culture = as.factor(Pearl_Harvest_Data_Days_of_Pearl_Culture)
  )

# Drop unused factor levels
host_dat <- droplevels(host_dat)

# Filter for complete cases needed for the model
host_dat_clean <- host_dat %>%
  filter(complete.cases(
    pred,
    offspring_id_host,
    Pearl_Harvest_Data_Days_of_Pearl_Culture
  ))

# Add 'units' column
host_dat_clean$units <- 1:nrow(host_dat_clean)

# Prepare pedigree and inverse
ped <- host_dat_clean %>%
  select(ID = offspring_id_host, SIRE = sire_host, DAM = dam_host) %>%
  distinct(ID, .keep_all = TRUE)  # Remove duplicated IDs
ped <- data.frame(lapply(ped, as.factor))



ainv <- ainverse(ped)

# Fit Gaussian animal model with ASReml
mod_host <- asreml(
  fixed = pred ~ Pearl_Harvest_Data_Days_of_Pearl_Culture ,
  random = ~ vm(offspring_id_host, ainv),
  residual = ~ idv(units),
  data = host_dat_clean
)

# Update and extract variance components
mod_host <- update.asreml(mod_host)
summary(mod_host)$varcomp

# Update model again to ensure convergence
mod_host <- update.asreml(mod_host)


# Extract variance components
vc <- summary(mod_host)$varcomp
print(vc)

# Calculate heritability
vpredict(mod_host, h2 ~ V1 / (V1 + V2))

# Extract BLUPs

blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
head(blup_host)

#blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
#blup_host$host <- gsub("^.*\\)_", "", rownames(blup_host))
#blup_host <- blup_host %>%
#filter(host %in% unique(host_dat_clean$offspring_id_host)) %>%
#mutate(EBV = solution)

# View top 10 BLUPs
#head(blup_host[order(-blup_host$EBV), ], 10)

```


# Gold quantitative host - fixed effects:  Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
host_dat <- hostquant2 %>%
  filter(
    !is.na(Shell_Metrics_GenotypeID_DART),
    !is.na(host_Dam),
    !is.na(host_Sire),
    !is.na(pred)
  )

# Convert ID columns and fixed effects
host_dat <- host_dat %>%
  mutate(
    offspring_id_host = as.factor(Shell_Metrics_GenotypeID_DART),
    dam_host = as.factor(host_Dam),
    sire_host = as.factor(host_Sire),

    # Fixed effects

    Matched_Donor_Data_Saibo_No = as.factor(Matched_Donor_Data_Saibo_No)
  )

# Drop unused factor levels
host_dat <- droplevels(host_dat)

# Filter for complete cases needed for the model
host_dat_clean <- host_dat %>%
  filter(complete.cases(
    pred,
    offspring_id_host,
    Matched_Donor_Data_Saibo_No
  ))

# Add 'units' column
host_dat_clean$units <- 1:nrow(host_dat_clean)

# Prepare pedigree and inverse
ped <- host_dat_clean %>%
  select(ID = offspring_id_host, SIRE = sire_host, DAM = dam_host) %>%
  distinct(ID, .keep_all = TRUE)  # Remove duplicated IDs
ped <- data.frame(lapply(ped, as.factor))



ainv <- ainverse(ped)

# Fit Gaussian animal model with ASReml
mod_host <- asreml(
  fixed = pred ~ Matched_Donor_Data_Saibo_No,
  random = ~ vm(offspring_id_host, ainv),
  residual = ~ idv(units),
  data = host_dat_clean
)

# Update and extract variance components
mod_host <- update.asreml(mod_host)
summary(mod_host)$varcomp

# Update model again to ensure convergence
mod_host <- update.asreml(mod_host)


# Extract variance components
vc <- summary(mod_host)$varcomp
print(vc)

# Calculate heritability
vpredict(mod_host, h2 ~ V1 / (V1 + V2))

# Extract BLUPs

blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
head(blup_host)

#blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
#blup_host$host <- gsub("^.*\\)_", "", rownames(blup_host))
#blup_host <- blup_host %>%
#filter(host %in% unique(host_dat_clean$offspring_id_host)) %>%
#mutate(EBV = solution)

# View top 10 BLUPs
#head(blup_host[order(-blup_host$EBV), ], 10)

```


# Gold quantitative host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
host_dat <- hostquant2 %>%
  filter(
    !is.na(Shell_Metrics_GenotypeID_DART),
    !is.na(host_Dam),
    !is.na(host_Sire),
    !is.na(pred)
  )

# Convert ID columns and fixed effects
host_dat <- host_dat %>%
  mutate(
    offspring_id_host = as.factor(Shell_Metrics_GenotypeID_DART),
    dam_host = as.factor(host_Dam),
    sire_host = as.factor(host_Sire),

    # Fixed effects
    First_Op_Data_Nuclei_Size_mm = as.numeric(First_Op_Data_Nuclei_Size_mm),
    Pearl_Harvest_Data_Days_of_Pearl_Culture = as.factor(Pearl_Harvest_Data_Days_of_Pearl_Culture)
  )

# Drop unused factor levels
host_dat <- droplevels(host_dat)

# Filter for complete cases needed for the model
host_dat_clean <- host_dat %>%
  filter(complete.cases(
    pred,
    offspring_id_host,
    First_Op_Data_Nuclei_Size_mm,
    Pearl_Harvest_Data_Days_of_Pearl_Culture
  ))

# Add 'units' column
host_dat_clean$units <- 1:nrow(host_dat_clean)

# Prepare pedigree and inverse
ped <- host_dat_clean %>%
  select(ID = offspring_id_host, SIRE = sire_host, DAM = dam_host) %>%
  distinct(ID, .keep_all = TRUE)  # Remove duplicated IDs
ped <- data.frame(lapply(ped, as.factor))



ainv <- ainverse(ped)

# Fit Gaussian animal model with ASReml
mod_host <- asreml(
  fixed = pred ~ First_Op_Data_Nuclei_Size_mm +
                 Pearl_Harvest_Data_Days_of_Pearl_Culture ,
  random = ~ vm(offspring_id_host, ainv),
  residual = ~ idv(units),
  data = host_dat_clean
)

# Update and extract variance components
mod_host <- update.asreml(mod_host)
summary(mod_host)$varcomp

# Update model again to ensure convergence
mod_host <- update.asreml(mod_host)


# Extract variance components
vc <- summary(mod_host)$varcomp
print(vc)

# Calculate heritability
vpredict(mod_host, h2 ~ V1 / (V1 + V2))

# Extract BLUPs

blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
head(blup_host)

#blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
#blup_host$host <- gsub("^.*\\)_", "", rownames(blup_host))
#blup_host <- blup_host %>%
#filter(host %in% unique(host_dat_clean$offspring_id_host)) %>%
#mutate(EBV = solution)

# View top 10 BLUPs
#head(blup_host[order(-blup_host$EBV), ], 10)

```


# Gold quantitative host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
host_dat <- hostquant2 %>%
  filter(
    !is.na(Shell_Metrics_GenotypeID_DART),
    !is.na(host_Dam),
    !is.na(host_Sire),
    !is.na(pred)
  )

# Convert ID columns and fixed effects
host_dat <- host_dat %>%
  mutate(
    offspring_id_host = as.factor(Shell_Metrics_GenotypeID_DART),
    dam_host = as.factor(host_Dam),
    sire_host = as.factor(host_Sire),

    # Fixed effects
    First_Op_Data_Nuclei_Size_mm = as.numeric(First_Op_Data_Nuclei_Size_mm),
    Matched_Donor_Data_Saibo_No = as.factor(Matched_Donor_Data_Saibo_No)
  )

# Drop unused factor levels
host_dat <- droplevels(host_dat)

# Filter for complete cases needed for the model
host_dat_clean <- host_dat %>%
  filter(complete.cases(
    pred,
    offspring_id_host,
    First_Op_Data_Nuclei_Size_mm,
    Matched_Donor_Data_Saibo_No
  ))

# Add 'units' column
host_dat_clean$units <- 1:nrow(host_dat_clean)

# Prepare pedigree and inverse
ped <- host_dat_clean %>%
  select(ID = offspring_id_host, SIRE = sire_host, DAM = dam_host) %>%
  distinct(ID, .keep_all = TRUE)  # Remove duplicated IDs
ped <- data.frame(lapply(ped, as.factor))



ainv <- ainverse(ped)

# Fit Gaussian animal model with ASReml
mod_host <- asreml(
  fixed = pred ~ First_Op_Data_Nuclei_Size_mm +
                 Matched_Donor_Data_Saibo_No,
  random = ~ vm(offspring_id_host, ainv),
  residual = ~ idv(units),
  data = host_dat_clean
)

# Update and extract variance components
mod_host <- update.asreml(mod_host)
summary(mod_host)$varcomp

# Update model again to ensure convergence
mod_host <- update.asreml(mod_host)


# Extract variance components
vc <- summary(mod_host)$varcomp
print(vc)

# Calculate heritability
vpredict(mod_host, h2 ~ V1 / (V1 + V2))

# Extract BLUPs

blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
head(blup_host)

#blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
#blup_host$host <- gsub("^.*\\)_", "", rownames(blup_host))
#blup_host <- blup_host %>%
#filter(host %in% unique(host_dat_clean$offspring_id_host)) %>%
#mutate(EBV = solution)

# View top 10 BLUPs
#head(blup_host[order(-blup_host$EBV), ], 10)

```

# Gold quantitative host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
host_dat <- hostquant2 %>%
  filter(
    !is.na(Shell_Metrics_GenotypeID_DART),
    !is.na(host_Dam),
    !is.na(host_Sire),
    !is.na(pred)
  )

# Convert ID columns and fixed effects
host_dat <- host_dat %>%
  mutate(
    offspring_id_host = as.factor(Shell_Metrics_GenotypeID_DART),
    dam_host = as.factor(host_Dam),
    sire_host = as.factor(host_Sire),

    # Fixed effects
    Pearl_Harvest_Data_Days_of_Pearl_Culture = as.factor(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    Matched_Donor_Data_Saibo_No = as.factor(Matched_Donor_Data_Saibo_No)
  )

# Drop unused factor levels
host_dat <- droplevels(host_dat)

# Filter for complete cases needed for the model
host_dat_clean <- host_dat %>%
  filter(complete.cases(
    pred,
    offspring_id_host,
    Pearl_Harvest_Data_Days_of_Pearl_Culture,
    Matched_Donor_Data_Saibo_No
  ))

# Add 'units' column
host_dat_clean$units <- 1:nrow(host_dat_clean)

# Prepare pedigree and inverse
ped <- host_dat_clean %>%
  select(ID = offspring_id_host, SIRE = sire_host, DAM = dam_host) %>%
  distinct(ID, .keep_all = TRUE)  # Remove duplicated IDs
ped <- data.frame(lapply(ped, as.factor))



ainv <- ainverse(ped)

# Fit Gaussian animal model with ASReml
mod_host <- asreml(
  fixed = pred ~ Pearl_Harvest_Data_Days_of_Pearl_Culture +
                 Matched_Donor_Data_Saibo_No,
  random = ~ vm(offspring_id_host, ainv),
  residual = ~ idv(units),
  data = host_dat_clean
)

# Update and extract variance components
mod_host <- update.asreml(mod_host)
summary(mod_host)$varcomp

# Update model again to ensure convergence
mod_host <- update.asreml(mod_host)


# Extract variance components
vc <- summary(mod_host)$varcomp
print(vc)

# Calculate heritability
vpredict(mod_host, h2 ~ V1 / (V1 + V2))

# Extract BLUPs

blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
head(blup_host)

#blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
#blup_host$host <- gsub("^.*\\)_", "", rownames(blup_host))
#blup_host <- blup_host %>%
#filter(host %in% unique(host_dat_clean$offspring_id_host)) %>%
#mutate(EBV = solution)

# View top 10 BLUPs
#head(blup_host[order(-blup_host$EBV), ], 10)

```


# Gold quantitative host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
host_dat <- hostquant2 %>%
  filter(
    !is.na(Shell_Metrics_GenotypeID_DART),
    !is.na(host_Dam),
    !is.na(host_Sire),
    !is.na(pred)
  )

# Convert ID columns and fixed effects
host_dat <- host_dat %>%
  mutate(
    offspring_id_host = as.factor(Shell_Metrics_GenotypeID_DART),
    dam_host = as.factor(host_Dam),
    sire_host = as.factor(host_Sire),

    # Fixed effects
    First_Op_Data_Nuclei_Size_mm = as.numeric(First_Op_Data_Nuclei_Size_mm),
    Pearl_Harvest_Data_Days_of_Pearl_Culture = as.factor(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    Matched_Donor_Data_Saibo_No = as.factor(Matched_Donor_Data_Saibo_No)
  )

# Drop unused factor levels
host_dat <- droplevels(host_dat)

# Filter for complete cases needed for the model
host_dat_clean <- host_dat %>%
  filter(complete.cases(
    pred,
    offspring_id_host,
    First_Op_Data_Nuclei_Size_mm,
    Pearl_Harvest_Data_Days_of_Pearl_Culture,
    Matched_Donor_Data_Saibo_No
  ))

# Add 'units' column
host_dat_clean$units <- 1:nrow(host_dat_clean)

# Prepare pedigree and inverse
ped <- host_dat_clean %>%
  select(ID = offspring_id_host, SIRE = sire_host, DAM = dam_host) %>%
  distinct(ID, .keep_all = TRUE)  # Remove duplicated IDs
ped <- data.frame(lapply(ped, as.factor))



ainv <- ainverse(ped)

# Fit Gaussian animal model with ASReml
mod_host <- asreml(
  fixed = pred ~ First_Op_Data_Nuclei_Size_mm +
                 Pearl_Harvest_Data_Days_of_Pearl_Culture +
                 Matched_Donor_Data_Saibo_No,
  random = ~ vm(offspring_id_host, ainv),
  residual = ~ idv(units),
  data = host_dat_clean
)

# Update and extract variance components
mod_host <- update.asreml(mod_host)
summary(mod_host)$varcomp

# Update model again to ensure convergence
mod_host <- update.asreml(mod_host)


# Extract variance components
vc <- summary(mod_host)$varcomp
print(vc)

# Calculate heritability
vpredict(mod_host, h2 ~ V1 / (V1 + V2))

# Extract BLUPs

blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
head(blup_host)

#blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
#blup_host$host <- gsub("^.*\\)_", "", rownames(blup_host))
#blup_host <- blup_host %>%
#filter(host %in% unique(host_dat_clean$offspring_id_host)) %>%
#mutate(EBV = solution)

# View top 10 BLUPs
#head(blup_host[order(-blup_host$EBV), ], 10)

```


# Gold quantitative donor - no fixed effects


# Gold quantitative donor - fixed effects: First_Op_Data_Nuclei_Size_mm


# Gold quantitative donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Gold quantitative donor - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture






# pearson correlation EBV vs observed proportion of Gold [donor binary model]


# pearson correlation EBV vs observed proportion of Gold [donor quantitative model]





# ROC Curves: Binary vs Quantitative Model (AUC)






# GASTON replace pedigree with GRM




# Gold binary host - fixed effects: First_Op_Data_Nuclei_Size_mm


# Gold binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Gold binary host - fixed effects:  Matched_Donor_Data_Saibo_No


# Gold binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture


# Gold binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No


# Gold binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No


# Gold binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No







# Silver binary host - no fixed effects 


# Silver binary host - fixed effects: First_Op_Data_Nuclei_Size_mm


# Silver binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Silver binary host - fixed effects:  Matched_Donor_Data_Saibo_No


# Silver binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture


# Silver binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No


# Silver binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No


# Silver binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No






# White binary host - no fixed effects 


# White binary host - fixed effects: First_Op_Data_Nuclei_Size_mm


# White binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# White binary host - fixed effects:  Matched_Donor_Data_Saibo_No


# White binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture


# White binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No


# White binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No


# White binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No






# Cream binary host - no fixed effects 


# Cream binary host - fixed effects: First_Op_Data_Nuclei_Size_mm


# Cream binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Cream binary host - fixed effects:  Matched_Donor_Data_Saibo_No


# Cream binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture


# Cream binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No


# Cream binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No


# Cream binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No






# Champagne binary host - no fixed effects 


# Champagne binary host - fixed effects: First_Op_Data_Nuclei_Size_mm


# Champagne binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Champagne binary host - fixed effects:  Matched_Donor_Data_Saibo_No


# Champagne binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture


# Champagne binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No


# Champagne binary host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No


# Champagne binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No





























# Gold binary donor - no fixed effects

# Gold binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm


# Gold binary donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Gold binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture







# Silver binary donor - no fixed effects

# Silver binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm


# Silver binary donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Silver binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture





# White binary donor - no fixed effects


# White binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm


# White binary donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# White binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture





# Cream binary donor - no fixed effects


# Cream binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm


# Cream binary donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Cream binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture




# Champagne binary donor - no fixed effects


# Champagne binary donor - fixed effects: First_Op_Data_Nuclei_Size_mm


# Champagne binary donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Champagne binary host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture



#VPREDICT 

# Gold quantitative host - no fixed effects


# Gold quantitative host - fixed effects: First_Op_Data_Nuclei_Size_mm


# Gold quantitative host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Gold quantitative host - fixed effects:  Matched_Donor_Data_Saibo_No


# Gold quantitative host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture


# Gold quantitative host - fixed effects: First_Op_Data_Nuclei_Size_mm, Matched_Donor_Data_Saibo_No


# Gold quantitative host - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No


# Gold quantitative host - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture, Matched_Donor_Data_Saibo_No




# Gold quantitative donor - no fixed effects


# Gold quantitative donor - fixed effects: First_Op_Data_Nuclei_Size_mm


# Gold quantitative donor - fixed effects: Pearl_Harvest_Data_Days_of_Pearl_Culture


# Gold quantitative donor - fixed effects: First_Op_Data_Nuclei_Size_mm, Pearl_Harvest_Data_Days_of_Pearl_Culture






# pearson correlation EBV vs observed proportion of Gold [donor binary model]


# pearson correlation EBV vs observed proportion of Gold [donor quantitative model]





# ROC Curves: Binary vs Quantitative Model (AUC)


