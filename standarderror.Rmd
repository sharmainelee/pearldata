---
title: "standarderror"
output: html_document
date: "2025-07-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## TRADITIONAL HERITABILITY ESTIMATES AND BLUP

# HOST

# HOST GOLD
```{r}

# Latent scale tells you the heritability on a theoretical continuous trait that gives rise to the binary outcome.

#Observed scale tells you how much of the 0/1 variation is due to genetics — and is usually much lower, especially when the trait is rare

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)

# 4. Ensure shell metrics are numeric
host_dat$Pearl_Harvest_Data_DVH_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_DVH_mm)
host_dat$Pearl_Harvest_Data_APW_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_APW_mm)
host_dat$Pearl_Harvest_Data_Shell_Weight_g <- as.numeric(host_dat$Pearl_Harvest_Data_Shell_Weight_g)

# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Gold),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(Pearl_Harvest_Data_APW_mm),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for Gold (binary trait)
mod.ind <- asreml(
  fixed = Gold ~ Pearl_Harvest_Data_DVH_mm + Pearl_Harvest_Data_APW_mm + Pearl_Harvest_Data_Shell_Weight_g,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)


# calculate heritability on the observed scale from your animal model for a binary trait (like Gold). This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).

# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait (Gold)
p <- mean(host_dat_clean$Gold, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

#Heritability (latent scale):   0.9825
#Heritability (observed scale): 0.2416

#vpredict(mod.ind,h2~V1/(V1+V2))


## STANDARD ERROR FOR LATENT HERITABILITY

# Extract values from your model
Va  <- 56.28088       # variance component for host_id
SEa <- 3.617537       # standard error of Va
Ve  <- 1.0            # residual variance (fixed in logistic models)

# 1. Heritability on the latent scale
h2_latent <- Va / (Va + Ve)

# 2. Delta method: derivative of h2 w.r.t Va
dVa <- Ve / (Va + Ve)^2

# 3. Standard error of h2_latent
SE_h2_latent <- SEa * dVa

# 4. Print results
cat("Heritability (latent scale):", round(h2_latent, 4), "\n")
cat("Standard Error (latent scale):", round(SE_h2_latent, 4), "\n")


#Heritability (latent scale): 0.9825 
#Standard Error (latent scale): 0.0011

## STANDARD ERROR FOR OBSERVED HERITABILITY

# From your model
Va <- vc["vm(host_id, ainv)", "component"]
SE_Va <- vc["vm(host_id, ainv)", "std.error"]
Ve <- 1

# Latent h2 and SE (delta method)
h2_latent <- Va / (Va + Ve)
SE_latent <- SE_Va * Ve / (Va + Ve)^2  # Chain rule

# Prevalence and transformation
p <- mean(host_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)

# Observed-scale h2 and SE
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
SE_obs <- (SE_latent * phi_z^2) / (p * (1 - p))

cat("Observed-scale heritability:", round(h2_obs, 4), "\n")
cat("Standard error:", round(SE_obs, 4), "\n")

#Observed-scale heritability: 0.2416 
#Standard error: 3e-04

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

BLUP$prob_gold



```



# HOST SILVER

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)
host_dat$First_Op_Data_Saibo_Area    <- as.factor(host_dat$First_Op_Data_Saibo_Area)

# 4. Ensure shell metrics are numeric
host_dat$First_Op_Data_Nuclei_Size_mm         <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)


# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Silver),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(First_Op_Data_Saibo_Area),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for Gold (binary trait)
mod.ind <- asreml(
  fixed = Silver ~ First_Op_Data_Nuclei_Size_mm + First_Op_Data_Saibo_Area,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# calculate heritability on the observed scale from your animal model for a binary trait. This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).



# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait (Gold)
p <- mean(host_dat_clean$Silver, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# Heritability (latent scale):   0.9884 
# Heritability (observed scale): 0.3643 

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

BLUP$prob_silver

```



# HOST WHITE

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)
host_dat$First_Op_Data_Saibo_Area    <- as.factor(host_dat$First_Op_Data_Saibo_Area)

# 4. Ensure shell metrics are numeric
host_dat$Pearl_Harvest_Data_DVH_mm         <- as.numeric(host_dat$Pearl_Harvest_Data_DVH_mm)
host_dat$Pearl_Harvest_Data_Shell_Weight_g         <- as.numeric(host_dat$Pearl_Harvest_Data_Shell_Weight_g)

# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(White),
    !is.na(Pearl_Harvest_Data_DVH_mm),
    !is.na(First_Op_Data_Saibo_Area),
    !is.na(Pearl_Harvest_Data_Shell_Weight_g),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for White (binary trait)
mod.ind <- asreml(
  fixed = White ~ Pearl_Harvest_Data_DVH_mm + First_Op_Data_Saibo_Area + Pearl_Harvest_Data_Shell_Weight_g,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# calculate heritability on the observed scale from your animal model for a binary trait. This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).



# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait 
p <- mean(host_dat_clean$White, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")


# Heritability (latent scale):   0.9949
# Heritability (observed scale): 0.5804

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

#BLUP$prob_white <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

#BLUP$prob_white

```




# HOST CREAM 

```{r}
# very high EBVs abnormal with both fixed effects, found out if i use it separately the EBVs are okay. so i scaled it. This will not affect the binary nature of Cream, only improve the handling of the covariates.

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)


# 4. Ensure numeric
#host_dat$First_Op_Data_DVH_mm         <- as.numeric(host_dat$First_Op_Data_DVH_mm)
host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)

# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_DVH_mm),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for White (binary trait)
mod.ind <- asreml(
  fixed = Cream ~ First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# calculate heritability on the observed scale from your animal model for a binary trait. This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).



# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait 
p <- mean(host_dat_clean$Cream, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")


# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

BLUP$prob_cream <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

BLUP$prob_cream




```




```{r}

# doesn't work even when outliers removed

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)


# 4. Ensure numeric
host_dat$First_Op_Data_DVH_mm         <- as.numeric(host_dat$First_Op_Data_DVH_mm)
host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)

# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_DVH_mm),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id)
  )

host_dat_no_outliers <- host_dat_clean %>%
  filter(First_Op_Data_DVH_mm >= 100, First_Op_Data_DVH_mm <= 150)



# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for White (binary trait)
mod.ind <- asreml(
  fixed = Cream ~ First_Op_Data_DVH_mm + First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# calculate heritability on the observed scale from your animal model for a binary trait. This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).



# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait 
p <- mean(host_dat_clean$Cream, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")


# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

#BLUP$prob_cream <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

#BLUP$prob_cream

```




```{r}

# tried to downsample but also doesn't work. 

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)

# 4. Ensure numeric
host_dat$First_Op_Data_DVH_mm         <- as.numeric(host_dat$First_Op_Data_DVH_mm)
host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)

# 5. Remove rows with missing values
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_DVH_mm),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id),
    !is.na(Dam),
    !is.na(Sire)
  )

# 6. Filter out DVH outliers
host_dat_no_outliers <- host_dat_clean %>%
  filter(First_Op_Data_DVH_mm >= 100, First_Op_Data_DVH_mm <= 150)

# 7. Downsample to balance Cream (1:5 ratio)
set.seed(123)
cream_1 <- host_dat_no_outliers %>% filter(Cream == 1)
cream_0 <- host_dat_no_outliers %>% filter(Cream == 0)
cream_0_sample <- cream_0 %>% sample_n(nrow(cream_1) * 5)
host_balanced <- bind_rows(cream_1, cream_0_sample)

# 8. Create pedigree and inverse relationship matrix
pedind <- host_balanced[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))
ainv <- ainverse(pedind)

# 9. Fit animal model for Cream (binary trait)
mod.ind <- asreml(
  fixed = Cream ~ First_Op_Data_DVH_mm + First_Op_Data_Nuclei_Size_mm,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_balanced,
  family = asr_binomial(link = "logit")
)

# 10. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 11. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 12. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# 13. Heritability calculation
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model
h2_latent <- Va / (Va + Ve)

p <- mean(host_balanced$Cream, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 14. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# 15. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)


# 16. Show top rows
head(BLUP)



```



```{r}
# scale is best 

#Scaling does not affect BLUPs or heritability structure
#Random effects and ainv matrix are independent of the scale of the fixed effects.
#So your heritability estimates and BLUPs remain interpretable — you just get a more numerically stable model.

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)

# 4. Ensure numeric
host_dat$First_Op_Data_DVH_mm         <- as.numeric(host_dat$First_Op_Data_DVH_mm)
host_dat$First_Op_Data_Nuclei_Size_mm <- as.numeric(host_dat$First_Op_Data_Nuclei_Size_mm)

# 5. Remove rows with missing data and check pedigree completeness
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Cream),
    !is.na(First_Op_Data_DVH_mm),
    !is.na(First_Op_Data_Nuclei_Size_mm),
    !is.na(host_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 6. Check if there’s variation in the trait
if (length(unique(host_dat_clean$Cream)) < 2) {
  stop("No variation in Cream trait — all values are 0 or 1.")
}

# 7. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))
ainv <- ainverse(pedind)



# Scale predictors
host_dat_clean <- host_dat_clean %>%
  mutate(
    DVH_scaled = scale(First_Op_Data_DVH_mm),
    Nuclei_scaled = scale(First_Op_Data_Nuclei_Size_mm)
  )

# Fit simplified, scaled model
mod.ind <- asreml(
  fixed = Cream ~ DVH_scaled + Nuclei_scaled,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)


# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# 9. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # For logistic model

# 10. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 11. Prevalence and check for valid z-score
p <- mean(host_dat_clean$Cream, na.rm = TRUE)

if (p <= 0 | p >= 1) {
  warning("Trait prevalence is 0 or 1 — cannot compute observed-scale heritability.")
  h2_obs <- NA
} else {
  z <- qnorm(p)
  phi_z <- dnorm(z)
  h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))
}

# 12. Report
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# 13. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$host_id <- rownames(BLUP)
BLUP$prob_cream <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

```




# HOST cHAMPAGNE

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
host_dat <- read_csv("host_id.csv")

# 2. Create binary colour traits
host_dat$Gold   <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Gold"), 1, 0)
host_dat$Silver <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Silver"), 1, 0)
host_dat$White  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "White"), 1, 0)
host_dat$Cream  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Cream"), 1, 0)
host_dat$Champ  <- ifelse(startsWith(host_dat$Pearl_Grading_Data_Colour, "Champ"), 1, 0)

# 3. Format pedigree columns as factors
host_dat$host_id <- as.factor(host_dat$host_id)
host_dat$Dam     <- as.factor(host_dat$Dam)
host_dat$Sire    <- as.factor(host_dat$Sire)
host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture    <- as.factor(host_dat$Pearl_Harvest_Data_Days_of_Pearl_Culture)

# 4. Ensure shell metrics are numeric



# 5. Remove rows with missing values in relevant columns
host_dat_clean <- host_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Pearl_Harvest_Data_Days_of_Pearl_Culture),
    !is.na(host_id)
  )

# 6. Create pedigree and inverse relationship matrix
pedind <- host_dat_clean[, c("host_id", "Sire", "Dam")]
colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))

ainv <- ainverse(pedind)

# 7. Fit animal model for champ (binary trait)
mod.ind <- asreml(
  fixed = Champ ~ Pearl_Harvest_Data_Days_of_Pearl_Culture,
  random = ~ vm(host_id, ainv),
  residual = ~ idv(units),
  data = host_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# calculate heritability on the observed scale from your animal model for a binary trait. This gives a more interpretable estimate in terms of the actual 0/1 outcomes (i.e., real-world expression of color).



# 1. Extract variance components
vc <- summary(mod.ind)$varcomp
Va <- vc["vm(host_id, ainv)", "component"]
Ve <- 1  # residual variance for logistic model

# 2. Latent-scale heritability
h2_latent <- Va / (Va + Ve)

# 3. Calculate prevalence of trait 
p <- mean(host_dat_clean$Champ, na.rm = TRUE)  # Proportion of "1"s

# 4. Find threshold z and normal density at z
z <- qnorm(p)
phi_z <- dnorm(z)

# 5. Observed-scale heritability
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 6. Print results
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

## Heritability (latent scale):  
## Heritability (observed scale):

# 11. Extract BLUPs
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
head(BLUP)

BLUP$prob_champ <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

BLUP$prob_champ

```



## DONOR




# DONOR GOLD

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Gold),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)



# 8. Fit the animal model
mod.ind <- asreml(
  fixed = Gold ~ 1,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)





# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# 10. Calculate heritability (latent scale)
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance for logistic models
h2_latent <- Va / (Va + Ve)

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Gold, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# 13. Extract BLUPs (genetic merit)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
actual_ids <- unique(donor_dat_clean$donor_id)
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
BLUP$prob_gold <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

```



# DONOR SILVER 

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Silver),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Ensure fixed effect is factor
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(
  donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round
)

# 8. Fit the animal model
mod.ind <- asreml(
  fixed = Silver ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),          # Genetic effect
  residual = ~ idv(units),                # Independent residuals
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # Binary trait model
)



# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# 10. Calculate heritability (latent scale)
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance for logistic models
h2_latent <- Va / (Va + Ve)

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

#Heritability (latent scale):   0.2254 
#Heritability (observed scale): 0.0583 

# 13. Extract BLUPs (genetic merit)
#BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
#BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))
#head(BLUP)

# Extract actual donor IDs (with prefix formatting if applied)
actual_ids <- unique(donor_dat_clean$donor_id)

# Extract donor_id from rownames
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

```





# DONOR WHITE

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Convert relevant columns to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 3. Create binary traits from Pearl_Grading_Data_Colour (starting string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ",  Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )

# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(White),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )

# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam) %>%
  rename(ID = donor_id, SIRE = Sire, DAM = Dam) %>%
  mutate(across(everything(), as.factor))

# 6. Generate inverse relationship matrix
ainv <- ainverse(pedind)

# 7. Convert fixed effect column to factor
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(
  donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round
)

# 8. Fit animal model
mod.ind <- asreml(
  fixed = White ~ Matched_Donor_Data_Nacre_lip_colour_Round,
  random = ~ vm(donor_id, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")
)

# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)



# 10. Calculate heritability (latent scale)
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance for logistic
h2_latent <- Va / (Va + Ve)

# 11. Adjust to observed scale using trait prevalence
p <- mean(donor_dat_clean$White, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")

# 13. Extract BLUPs (filter for donor_id only)
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))
actual_ids <- as.character(unique(donor_dat_clean$donor_id))
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# 14. Calculate probabilities
BLUP$prob_white <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

# View top rows
head(BLUP)

```



# DONOR CREAM

```{r}


# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )

# 4. Ensure shell metrics are numeric
donor_dat$Matched_Donor_Data_DVH_mm         <- as.numeric(donor_dat$Matched_Donor_Data_DVH_mm)
donor_dat$Matched_Donor_Data_Shell_Weight_g         <- as.numeric(donor_dat$Matched_Donor_Data_Shell_Weight_g)

# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )



# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Cream),
    !is.na(Matched_Donor_Data_DVH_mm),
    !is.na(Matched_Donor_Data_Shell_Weight_g ),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)



# 8. Fit the animal model


mod.ind <- asreml(
  fixed = Cream ~ Matched_Donor_Data_DVH_mm + Matched_Donor_Data_Shell_Weight_g,
  random = ~ vm(donor_id, ainv),          # Genetic effect (multiple observations allowed)
  residual = ~ idv(units),                # Independent residuals per saibo observation
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # For binary trait (e.g., white presence)
)


# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# 10. Calculate heritability (latent scale)
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance for logistic models
h2_latent <- Va / (Va + Ve)

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")



# 13. Extract BLUPs (genetic merit)
#BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
#BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))
#head(BLUP)

# Extract actual donor IDs (with prefix formatting if applied)
actual_ids <- unique(donor_dat_clean$donor_id)

# Extract donor_id from rownames
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
BLUP$prob_cream <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

```



# DONOR CHAMPAGNE

```{r}

# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load data
donor_dat <- read_csv("donor_data.csv")

# 2. Fix column names and convert to factors
donor_dat <- donor_dat %>%
  mutate(
    donor_id = as.factor(donor_id),
    Dam = as.factor(dam),
    Sire = as.factor(sire)
  )



# 3. Create binary traits from Pearl_Grading_Data_Colour (start with string match)
donor_dat <- donor_dat %>%
  mutate(
    Gold   = ifelse(grepl("^Gold", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Silver = ifelse(grepl("^Silver", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    White  = ifelse(grepl("^White", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Cream  = ifelse(grepl("^Cream", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0),
    Champ  = ifelse(grepl("^Champ", Pearl_Grading_Data_Colour, ignore.case = TRUE), 1, 0)
  )


# 4. Filter for complete cases required for modelling
donor_dat_clean <- donor_dat %>%
  filter(
    !is.na(Champ),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Round),
    !is.na(Matched_Donor_Data_Nacre_lip_colour_Flat),
    !is.na(donor_id),
    !is.na(Sire),
    !is.na(Dam)
  )


# 5. Create a pedigree with unique donor IDs only
pedind <- donor_dat_clean %>%
  distinct(donor_id, .keep_all = TRUE) %>%
  select(donor_id, Sire, Dam)

colnames(pedind) <- c("ID", "SIRE", "DAM")
pedind <- data.frame(lapply(pedind, as.factor))  # Ensure factors

# 6. Generate the inverse relationship matrix (A-inverse)
ainv <- ainverse(pedind)

# 7. Ensure fixed effect is factor


#added this line to ensure the column is a factor:
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round <- as.factor(donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Round)
donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Flat <- as.factor(donor_dat_clean$Matched_Donor_Data_Nacre_lip_colour_Flat)

# 8. Fit the animal model


mod.ind <- asreml(
  fixed = Champ ~ Matched_Donor_Data_Nacre_lip_colour_Round + Matched_Donor_Data_Nacre_lip_colour_Flat,
  random = ~ vm(donor_id, ainv),          # Genetic effect (multiple observations allowed)
  residual = ~ idv(units),                # Independent residuals per saibo observation
  data = donor_dat_clean,
  family = asr_binomial(link = "logit")   # For binary trait (e.g., white presence)
)


# 8. Update and extract variance components
mod.ind <- update.asreml(mod.ind)
summary(mod.ind)$varcomp

# 8. Update model (again) to ensure convergence
mod.ind <- update.asreml(mod.ind)

# 9. Extract variance components manually
vc <- summary(mod.ind)$varcomp
print(vc)

# 10. Calculate heritability (latent scale)
Va <- vc["vm(donor_id, ainv)", "component"]
Ve <- 1  # Residual variance for logistic models
h2_latent <- Va / (Va + Ve)

# 11. Convert to observed scale using trait prevalence
p <- mean(donor_dat_clean$Silver, na.rm = TRUE)
z <- qnorm(p)
phi_z <- dnorm(z)
h2_obs <- (h2_latent * phi_z^2) / (p * (1 - p))

# 12. Print heritability estimates
cat("Heritability (latent scale):  ", round(h2_latent, 4), "\n")
cat("Heritability (observed scale):", round(h2_obs, 4), "\n")



# 13. Extract BLUPs (genetic merit)
#BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
#BLUP$prob_silver <- exp(BLUP$solution) / (1 + exp(BLUP$solution))
#head(BLUP)

# Extract actual donor IDs (with prefix formatting if applied)
actual_ids <- unique(donor_dat_clean$donor_id)

# Extract donor_id from rownames
BLUP <- as.data.frame(summary(mod.ind, coef = TRUE)$coef.random)
BLUP$donor_id <- sub(".*donor_id, ainv\\)_", "", rownames(BLUP))

# Filter only donor IDs used in model
BLUP <- BLUP %>% filter(donor_id %in% actual_ids)

# Optional: calculate probabilities
BLUP$prob_champ <- exp(BLUP$solution) / (1 + exp(BLUP$solution))

head(BLUP)

```







## QUANTITATIVE HERITABILITY ESTIMATE AND BLUP (EBV)


# HOST QUANTITATIVE 

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# 1. Load and clean host data
host_dat <- read_csv("hostquant.csv") %>%
  filter(!is.na(offspring_id_host) & !is.na(dam_host) & !is.na(sire_host) & !is.na(pred))

# 2. Convert ID columns to factors
host_dat$offspring_id_host <- as.factor(host_dat$offspring_id_host)
host_dat$dam_host <- as.factor(host_dat$dam_host)
host_dat$sire_host <- as.factor(host_dat$sire_host)

# 3. Prepare pedigree and create inverse relationship matrix
ped_host <- host_dat %>%
  distinct(offspring_id_host, .keep_all = TRUE) %>%
  select(ID = offspring_id_host, SIRE = sire_host, DAM = dam_host)
ped_host <- data.frame(lapply(ped_host, as.factor))
ainv_host <- ainverse(ped_host)

# 4. Filter complete cases for modeling
host_dat_clean <- host_dat %>%
  filter(complete.cases(pred, offspring_id_host))

# 5. Fit ASReml Gaussian animal model
mod_host <- asreml(
  fixed = pred ~ 1,
  random = ~ vm(offspring_id_host, ainv_host),
  residual = ~ idv(units),
  data = host_dat_clean
)
mod_host <- update(mod_host)

# 6. Extract variance components
vc_host <- summary(mod_host)$varcomp
print(vc_host)

# 7. Calculate heritability (latent scale)
Va_host <- vc_host["vm(offspring_id_host, ainv_host)", "component"]
Ve_host <- vc_host["units!R", "component"]
h2_latent_host <- Va_host / (Va_host + Ve_host)

# 8. Calculate heritability (observed scale)
pred_var_host <- var(host_dat_clean$pred, na.rm = TRUE)
h2_observed_host <- Va_host / pred_var_host

# 9. Print heritability estimates
cat("Gold heritability (latent scale):", round(h2_latent_host, 4), "\n")
cat("Gold heritability (observed scale):", round(h2_observed_host, 4), "\n")

# 10. Extract BLUPs
blup_host <- as.data.frame(summary(mod_host, coef = TRUE)$coef.random)
blup_host$host <- gsub("^.*\\)_", "", rownames(blup_host))
blup_host <- blup_host %>% filter(host %in% unique(host_dat_clean$offspring_id_host))
blup_host$EBV <- blup_host$solution

# 11. View top 10 BLUPs
head(blup_host[order(-blup_host$EBV), ], 10)

```






# DONOR QUANTITATIVE

```{r}
# Load required libraries
library(readr)
library(asreml)
library(nadiv)
library(dplyr)

# Load and clean data
donor_dat <- read_csv("donorquant.csv") %>%
  filter(!is.na(offspring_id_donor) & !is.na(dam_donor) & !is.na(sire_donor) & !is.na(pred))

# Convert columns to appropriate types
donor_dat$offspring_id_donor <- as.factor(donor_dat$offspring_id_donor)
donor_dat$dam_donor <- as.factor(donor_dat$dam_donor)
donor_dat$sire_donor <- as.factor(donor_dat$sire_donor)

# Prepare pedigree
ped <- donor_dat %>%
  distinct(offspring_id_donor, .keep_all = TRUE) %>%
  select(ID = offspring_id_donor, SIRE = sire_donor, DAM = dam_donor)
ped <- data.frame(lapply(ped, as.factor))
ainv <- ainverse(ped)

# Filter complete data for modeling
donor_dat_clean <- donor_dat %>%
  filter(complete.cases(pred, offspring_id_donor))

# Fit ASReml Gaussian animal model
mod_gold <- asreml(
  fixed = pred ~ 1,
  random = ~ vm(offspring_id_donor, ainv),
  residual = ~ idv(units),
  data = donor_dat_clean
)
mod_gold <- update(mod_gold)

# Extract variance components manually
vc <- summary(mod_gold)$varcomp
print(vc)  # Print all variance components
Va <- vc["vm(offspring_id_donor, ainv)", "component"]
Ve <- vc["units!R", "component"]

# Heritability (latent scale)
h2_latent <- Va / (Va + Ve)

# Heritability (observed scale)
pred_var <- var(donor_dat_clean$pred, na.rm = TRUE)
h2_observed <- Va / pred_var

# Output heritability estimates
cat("Gold heritability (latent scale):", round(h2_latent, 4), "\n")
cat("Gold heritability (observed scale):", round(h2_observed, 4), "\n")
#ignore latent scale its inaccurate 


# Extract BLUPs
blup_gold <- as.data.frame(summary(mod_gold, coef = TRUE)$coef.random)
blup_gold$donor <- gsub("^.*\\)_", "", rownames(blup_gold))
blup_gold <- blup_gold %>% filter(donor %in% unique(donor_dat_clean$offspring_id_donor))
blup_gold$EBV <- blup_gold$solution

# View top BLUPs
head(blup_gold[order(-blup_gold$EBV), ], 10)

```


# manual vpredict 

```{r}
 # Input variance components and their SEs
Va     <- 0.02216302       # Additive genetic variance
Va_se  <- 0.005141393      # SE of Va
Ve     <- 0.01752539       # Residual variance (units!units)
Ve_se  <- 0.001265809      # SE of Ve

# 1. Heritability (observed scale)
h2 <- Va / (Va + Ve)

# 2. Standard error of heritability (delta method)
denom <- (Va + Ve)^2

se_h2 <- sqrt(
  (Ve / denom)^2 * Va_se^2 +
  (Va / denom)^2 * Ve_se^2
)

# 3. Z-ratio
z_ratio <- h2 / se_h2

# 4. Output results
cat("Observed-scale heritability (h2):", round(h2, 4), "\n")
cat("Standard error of h2:", round(se_h2, 4), "\n")
cat("Z-ratio:", round(z_ratio, 2), "\n")

```




